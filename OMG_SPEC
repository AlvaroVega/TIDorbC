This release of TIDorbC++ follows:
- OMG CORBA Specification, Version 2.6
- OMG C++ Language Mapping Specification, Version 1.1
- OMG GIOP Compression (FTF Beta 2)
-------------------------------------------------------------------------------
The following Test Report represent the CORBA compliant:

#################
# Tests Summary #
#################

* TIDIdlC and TIDorbC Test Results


* IDL Syntax and Semantics (CORBA 2.6 - Chapter 3)
--------------------------------------------------

·Structural Tests
=================

Test Case IDL
-------------
Test                                                            Result
BasicTypes                                                      PASSED 33
AnyType                                                         PASSED  3
StructuredTypes                                                 PASSED 22
TemplateTypes                                                   PASSED 36
Native                                                          PASSED  1
Exceptions                                                      PASSED  8
Interfaces                                                      PASSED 30
Values                                                          PASSED 22  FAILED 10


* IDL To C++ Mapping (C++ Language Mapping Specification Version 1.1)
---------------------------------------------------------------------

·Functional Tests
=================

Test Case MappingCpp
--------------------
Test                                                            Result
BasicTypes                                                      PASSED 96
AnyType                                                         PASSED 98 FAILED 2
StructuredTypes                                                 PASSED 158
TemplateTypes                                                   PASSED 331
Native                                                          PASSED 1
Exceptions                                                      PASSED 12
Interfaces                                                      PASSED 77
Values                                                          PASSED 48


* CORBA CORE (CORBA 2.6 - Chapter 4)
-------------------------------------

·Structural Tests
=================

Test Case CORBA_CORE
--------------------
Test                                                            Result
ORBInterface                                                    PASSED 41
ObjectOperations                                                PASSED 15
ContextObjectOp                                                 PASSED 7
Typecodes                                                       PASSED 19
Exceptions                                                      PASSED 36


·Functional Tests
=================


Test Case CORBA_CORE
----------------------
Test                                                            Result
ORBInterface                                                    PASSED 169 FAILED 8
ObjectOperations                                                PASSED 36  FAILED 6
ContextObjectOp                                                 PASSED 4   FAILED 1
Typecodes                                                       PASSED 36  FAILED 3
Exceptions                                                      PASSED 160


* Internet Inter-ORB Protocol (CORBA 2.6 - Chapter 15)
------------------------------------------------------

·Functional Tests
=================

Test Case CDR
-------------
Test                                                            Result
GIOP_1_0                                                        PASSED 214
GIOP_1_1                                                        PASSED 214
GIOP_1_2                                                        PASSED 214


Test Case Interoperability
--------------------------
Test                                                            Result
GIOP_1_0                                                        PASSED 214
GIOP_1_1                                                        PASSED 214
GIOP_1_2                                                        PASSED 214


Test Case GIOPMessages
----------------------

Test                                                            Result
TID_GIOP_1_0                                                    PASSED 5
TID_GIOP_1_1                                                    PASSED 5
TID_GIOP_1_2                                                    PASSED 5
TAO_GIOP_1_0                                                    PASSED 5
TAO_GIOP_1_1                                                    PASSED 5
TAO_GIOP_1_2                                                    PASSED 5



Test Case Bidirectional
-----------------------
Test                                                            Result
TID_GIOP_1_2                                                    PASSED 2
TAO_GIOP_1_2                                                    PASSED 2


* DII - Dynamic Invocation Interface (CORBA 2.6 - Chapter 7)
------------------------------------------------------------

·Functional Tests
=================

Test Case 
-------------------
Test                                                            Result
NVListAPI                                                       PASSED 18
RequestAPI                                                      PASSED 33 FAILED 6



* DSI - Dynamic Skeleton Interface (CORBA 2.6 - Chapter 8)
----------------------------------------------------------

·Functional Tests
=================

Test Case 
--------------------------
Test                                                            Result
ServerRequestAPI                                                PASSED 18 FAILED 2


* Portable Object Adapter (CORBA 2.6 - Chapter 11)
--------------------------------------------------

·Structural Tests
=================

Test Case POA
-------------
Test                                                            Result
Interfaces                                                      PASSED 55


·Functional Tests
=================

Test Case 
-----------------------
Test                                                            Result
AbstractModel                                                   PASSED 67
POAInterfaces                                                   PASSED 53
Robustness_and_continuous_operation                             PASSED  1



* Dynamic ANY (CORBA 2.6 - Chapter 9)
-------------------------------------

·Structural Tests
=================

Test Case test
--------------
Test                                                            Result
DynAny::DynAnyFactoryAPI                                        PASSED 2
DynAny::DynAnyAPI                                               PASSED 80
DynAny::DerivedDynAnyAPIs                                       PASSED 39


·Functional Tests
=================

Test Case DynAnyFactoryAPI
--------------------------
Test                                                            Result
DynAnyFactoryAPI                                                PASSED 254 FAILED 8
DynAnyAPI                                                       PASSED 128 FAILED 1
DynArrayAPI                                                     PASSED 7
DynEnumAPI                                                      PASSED 10
DynFixedAPI                                                     PASSED 1
DynSequenceAPI                                                  PASSED 15
DynStructAPI                                                    PASSED 32                     
DynUnionAPI                                                     PASSED 21  FAILED 3



* Portable Interceptor CODECS (CORBA 2.6 - Chapter 13)
------------------------------------------------------

·Functional Tests
=================

Test Case Codecs
----------------
Test                                                            Result
BasicTypes                                                      PASSED 444  FAILED 24
ObjectTypes_and_Repetitions                                     PASSED 288
AnyTypes                                                        PASSED 108
StructTypes                                                     PASSED 117
Arrays                                                          PASSED 216


* MIOP (CORBA 2.6 - Chapter 29)
-------------------------------

·Structurals Tests
==================

Test Case MIOP
--------------
Test                                                            Result
GOA_Interface                                                   PASSED 6


·Functional Tests
=================

Test                                                            Result
GOA                                                             PASSED 4
MIOP URL                                                        PASSED 3
MIOP Packet Collection                                          PASSED 22


* Messaging QoS (CORBA 2.6 - Chapter 22)
----------------------------------------

·Structural Tests
=================

Test Case CORBA_Messaging
-------------------------
Test                                                            Result
Messaging_QoS                                                   PASSED 29


·Functional Tests
=================

Test Case Messaging_QoS
-----------------------
Test                                                            Result
RequestPriorityPolicy                                           PASSED 5
RequestStart_EndTimeoutPolicy                                   PASSED 5
RebindPolicy                                                    PASSED 5
RelativeRequestTimeoutPolicy                                    PASSED 5
RelativeRequestTimeoutPolicy_2                                  PASSED 5
RelativeRoundtripTimeoutPolicy                                  PASSED 5
RelativeRoundtripTimeoutPolicy_2                                PASSED 5
QueueOrderPolicy                                                PASSED 5


* ZIOP (ZIOP FTF Beta 2)
------------------------

·Structural Tests
=================

Test Case GIOP_Compression
-------------------------
Test                                                            Result
Compression                                                     PASSED 22
ZIOP                                                            PASSED 8


·Functional Tests
=================

Test 
-----------------------
Test                                                            Result
ZIOP_Policies                                                   PASSED 12
ZlibCompressor                                                  PASSED 3
CustomCompressor                                                PASSED 3


-------------------------------------------------------------------------------
#################
# TOTALS        #
#################
                                                                
                    PASSED             FAILED            TOTAL
                  ----------         ----------        ---------             
Structured  |         3385                 10             3395

Functional  |         4462                 64             4526

TOTAL       |         7847                 74             7921


-------------------------------------------------------------------------------
#####################
# Tests Description #
#####################

* IDL Syntax and Semantics (CORBA 2.6 - Chapter 3)
--------------------------------------------------

·Structural Tests
=================

Test Case IDL
-------------
Test BasicTypes
	 

Test BasicTypes

typedef float FloatType                                         [OK]
typedef double DoubleType                                       [OK]
typedef long double LongDoubleType                              [OK]
typedef short ShortType                                         [OK]
typedef long LongType                                           [OK]
typedef long long LongLongType                                  [OK]
typedef unsigned short UnsignedShortType                        [OK]
typedef unsigned long UnsignedLongType                          [OK]
typedef unsigned long long UnsignedLongLongType                 [OK]
typedef char CharType                                           [OK]
typedef wchar WcharType                                         [OK]
typedef boolean BooleanType                                     [OK]
typedef octet OctetType                                         [OK]

typedef float FloatArray [ 1 ]                                  [OK]
typedef double DoubleArray [ 1 ]                                [OK]
typedef long double LDoubleArray [ 1 ]                          [OK]
typedef char CharArray [ 1 ]                                    [OK]
typedef wchar WCharArray [ 1 ]                                  [OK]
typedef boolean BooleanArray [ 1 ]                              [OK]
typedef octet OctetArray [ 1 ]                                  [OK]
typedef short ShortArray [ 1 ]                                  [OK]
typedef long LongArray [ 1 ]                                    [OK]
typedef long long LongLongArray [ 1 ]                           [OK]
typedef unsigned short UShortArray [ 1 ]                        [OK]
typedef unsigned long ULongArray [ 1 ]                          [OK]
typedef unsigned long long ULongLongArray [ 1 ]                 [OK]

typedef float FloatArrayBi [1][2]                               [OK]

typedef double d1 , d2                                          [OK]
typedef float f1 , f2 [ 1 ]                                     [OK]
typedef short s1 [ 1 ] , s2 [ 1 ]                               [OK]

typedef Object ObjectType, ObjectArray [1]                      [OK]
typedef ValueBase ValueBaseType, ValueBaseArray [1]             [OK]


Test AnyType

typedef any AnyType                                             [OK]
typedef any AnyArray [ 1 ]                                      [OK]
typedef any AnyFirst , AnySecond                                [OK]	 


Test StructuredTypes
	 
Struct with basic types                                         [OK]
Struct with arrays of basic types                               [OK]
Struct with templates                                           [OK]
Typedef struct                                                  [OK]
Forward declaration of struct                                   [OK]
Union with basic types and switch of type char                  [OK]
Union with basic types and switch of type integer               [OK]
Union with basic types and switch of type boolean               [OK]
Union with basic types and switch of type enum                  [OK]
Union with templates                                            [OK]
Typedef union                                                   [OK]
Forward declaration of union                                    [OK]
Enum declaration                                                [OK]
Typedef enum                                                    [OK]
Struct with nested structured types (struct, union, enum)       [OK]
Union with nested structured types (struct, union, enum)        [OK]
Struct with a nested struct (deprecated declaration)            [OK]
Struct with a nested union (deprecated declaration)             [OK]
Struct with a nested enum (deprecated declaration)              [OK]
Union with a nested struct (deprecated declaration)             [OK]
Union with a nested union (deprecated declaration)              [OK]
Union with a nested enum (deprecated declaration)               [OK]


Test TemplateTypes

typedef sequence<any,11>                                        [OK]
typedef sequence<any>                                           [OK]
typedef sequence<wchar,18>                                      [OK]
typedef sequence<wchar>                                         [OK]
typedef sequence<long double,11>                                [OK]
typedef sequence<long double>                                   [OK]
typedef sequence<double,18>                                     [OK]
typedef sequence<double>                                        [OK]
typedef sequence<float,11>                                      [OK]
typedef sequence<float>                                         [OK]
typedef sequence<long,18>                                       [OK]
typedef sequence<long>                                          [OK]
typedef sequence<short>                                         [OK]
typedef sequence<short,11>                                      [OK]
typedef sequence<unsigned long>                                 [OK]
typedef sequence<unsigned long,18>                              [OK]
typedef sequence<unsigned short>                                [OK]
typedef sequence<unsigned short,11>                             [OK]
typedef sequence<char>                                          [OK]
typedef sequence<char,18>                                       [OK]
typedef sequence<boolean>                                       [OK]
typedef sequence<boolean,11>                                    [OK]
typedef sequence<octet>                                         [OK]
typedef sequence<octet,18>                                      [OK]
typedef sequence<string,11>                                     [OK]
typedef sequence<string<2>,18>                                  [OK]
typedef sequence<string>                                        [OK]
typedef sequence<string<2> >                                    [OK]

Nested sequence                                                 [OK]
Array (unidimensional) of a Sequence Type                       [OK]
Array (bidimensional) of a Sequence Type                        [OK]

typedef string                                                  [OK]
typedef string <2>                                              [OK]

typedef wstring                                                 [OK]
typedef wstring <2>                                             [OK]

typedef fixed <2,2>                                             [OK]


Test Native
	 
Native declaration                                              [OK]


Test Exceptions
	 
Exception with no members                                       [OK]
Exception with basic types                                      [OK]
Exception with any                                              [OK]
Exception with sequence                                         [OK]
Exception with string                                           [OK]
Exception with struct (deprecated declaration)                  [OK]
Exception with struct                                           [OK]
Exception with array                                            [OK]


Test Interfaces
	 
Forward declaration interface                                   [OK]
Forward declaration local interface                             [OK]
Forward declaration abstract interface                          [OK]
Interface declaration                                           [OK]
Local interface declaration                                     [OK]
Abstract interface declaration                                  [OK]
Inheritance for interfaces                                      [OK]
Inheritance for local interfaces                                [OK]
Inheritance for abstract interfaces                             [OK]
Multiple inheritance                                            [OK]
operations with object references                               [OK]

type declarations 
   basic types                                                  [OK]
   any                                                          [OK]
   native                                                       [OK]
   constructed types                                            [OK]
   templates                                                    [OK]
constant declarations                                           [OK]
exception declarations                                          [OK]
attribute declaration                                           [OK]
operation oneway                                                [OK]
operations with all possible return values                      
  <void>                                                        [OK]
  <base_types>                                                  [OK]
  <string_type>                                                 [OK]
  <wide_string_type>                                            [OK]
  <scoped_name>                                                 [OK]
operations with all possible parameter declarations 
  in                                                            [OK]
  out                                                           [OK]
  nout                                                          [OK]
operation that raises expressions                               [OK]
operation with custom expressions                               [OK]


Test Values

Regular valuetype declaration with basic types                  [OK]
Regular valuetype declaration with constant basic types         [OK]
Regular valuetype declaration with an exception                 [OK]
Regular valuetype declaration with an attribute                 [OK]
Regular valuetype declaration with an operation                 [OK]
Regular valuetype initializers                                  [OK]
Regular valuetype declaration with a sequence type              [OK]
Regular valuetype declaration with a string type                [OK]
Regular valuetype declaration with a wstring type               [OK]
Regular valuetype declaration with a fixed type                 [OK]
Regular valuetype declaration with a struct types               [OK]
Regular valuetype declaration with a union type                 [OK]
Regular valuetype declaration with an enum type                 [OK]
Abstract valuetype declaration with basic types                 [OK]
Abstract valuetype declaration with a sequence type             [OK]
Abstract valuetype declaration with a string type               [OK]
Abstract valuetype declaration with a wstring type              [OK]
Abstract valuetype declaration with a fixed type                [OK]
Abstract valuetype declaration with a struct types              [OK]
Abstract valuetype declaration with a union type                [OK]
Abstract valuetype declaration with an enum type                [OK]
Valuetype inheritance                                           [OK]

Forward valuetype declaration                                   [ERROR]
Forward abstract valuetype declaration                          [ERROR]
Custom valuetype declaration with basic types                   [ERROR]
Custom valuetype declaration with a sequence type               [ERROR]
Custom valuetype declaration with a string type                 [ERROR]
Custom valuetype declaration with a wstring type                [ERROR]
Custom valuetype declaration with a fixed type                  [ERROR]
Custom valuetype declaration with a struct types                [ERROR]
Custom valuetype declaration with a union type                  [ERROR]
Custom valuetype declaration with an enum type                  [ERROR]



* IDL To C++ Mapping (C++ Language Mapping Specification Version 1.1)
---------------------------------------------------------------------

·Functional Tests
=================

Test Case MappingCpp
--------------------
Test BasicTypes

Boolean                                                         [OK]
Char                                                            [OK]
WChar                                                           [OK]
Octet                                                           [OK]
Short                                                           [OK]
UShort                                                          [OK]
Long                                                            [OK]
ULong                                                           [OK]
LongLong                                                        [OK]
ULongLong                                                       [OK]
Float                                                           [OK]
Double                                                          [OK]
LongDouble                                                      [OK]

Boolean_out                                                     [OK]
Char_out                                                        [OK]
WChar_out                                                       [OK]
Octet_out                                                       [OK]
Short_out                                                       [OK]
UShort_out                                                      [OK]
Long_out                                                        [OK]
ULong_out                                                       [OK]
LongLong_out                                                    [OK]
ULongLong_out                                                   [OK]
Float_out                                                       [OK]
Double_out                                                      [OK]
LongDouble_out                                                  [OK]

_tc_Boolean                                                     [OK]
_tc_Char                                                        [OK]
_tc_WChar                                                       [OK]
_tc_Octet                                                       [OK]
_tc_Short                                                       [OK]
_tc_UShort                                                      [OK]
_tc_Long                                                        [OK]
_tc_ULong                                                       [OK]
_tc_LongLong                                                    [OK]
_tc_ULongLong                                                   [OK]
_tc_Float                                                       [OK]
_tc_Double                                                      [OK]
_tc_LongDouble                                                  [OK]

FloatArray                                                      [OK]
FloatArray_var                                                  [OK]
_tc_FloatArray                                                  [OK]
FloatArray_slice                                                [OK]
FloatArray_forany                                               [OK]
FloatArray_slice *FloatArray_alloc();                           [OK]
FloatArray_slice *FloatArray_dup(const FloatArray_slice*);      [OK]
void FloatArray_copy(FloatArray_slice* to, from);               [OK]
void FloatArray_free(FloatArray_slice *);                       [OK]

FloatArrayBi                                                    [OK]
FloatArrayBi_var                                                [OK]
_tc_FloatArrayBi                                                [OK]
FloatArrayBi_slice                                              [OK]
FloatArrayBi_forany                                             [OK]
FloatArrayBi_slice *FloatArrayBi_alloc();                       [OK]
FloatArrayBi_slice *FloatArrayBi_dup(const FloatArrayBi_sl*);   [OK]
void FloatArrayBi_copy(to, from);                               [OK]
void FloatArrayBi_free(FloatArrayBi_slice *);                   [OK]

double d1 , d2 ;                                                [OK]
float f1 , f2 [ 1 ] ;                                           [OK]
short s1 [ 1 ] , s2 [ 1 ] ;                                     [OK]

ObjectType                                                      [OK]
ObjectType_var                                                  [OK]
ObjectType_ptr                                                  [OK]
ObjectType_out                                                  [OK]
_tc_ObjectType                                                  [OK]

ValueBaseType                                                   [OK]
_tc_ValueBaseType                                               [OK]

typeid Boolean                                                  [OK]
typeid Char                                                     [OK]
typeid WChar                                                    [OK]
typeid Octet                                                    [OK]
typeid Short                                                    [OK]
typeid UShort                                                   [OK]
typeid Long                                                     [OK]
typeid ULong                                                    [OK]
typeid LongLong                                                 [OK]
typeid ULongLong                                                [OK]
typeid Float                                                    [OK]
typeid Double                                                   [OK]
typeid LongDouble                                               [OK]

assert(_tc_Boolean->kind());                                    [OK]
assert(_tc_Char->kind());                                       [OK]
assert(_tc_WChar->kind());                                      [OK]
assert(_tc_Octet->kind());                                      [OK]
assert(_tc_Short->kind());                                      [OK]
assert(_tc_UShort->kind());                                     [OK]
assert(_tc_Long->kind());                                       [OK]
assert(_tc_ULong->kind());                                      [OK]
assert(_tc_LongLong->kind());                                   [OK]
assert(_tc_ULongLong->kind());                                  [OK]
assert(_tc_Float->kind());                                      [OK]
assert(_tc_Double->kind());                                     [OK]
assert(_tc_LongDouble->kind());                                 [OK]
assert(_tc_ValueBaseType->kind());                              [OK]
assert(_tc_ObjectType->kind());                                 [OK]

	 

Test AnyType

Type Support: Any                                                       [OK]
Repetition: Any any_pos1, any_pos2;                                     [OK]

AnyArray                                                                [OK]
AnyArray_var                                                            [OK]
AnyArray_slice                                                          [OK]
AnyArray_forany                                                         [OK]
AnyArray_slice *AnyArray_alloc();                                       [OK]
AnyArray_slice *AnyArray_dup(const AnyArray_slice*);                    [OK]
void AnyArray_copy(AnyArray_slice* to, const AnyArray_slice* from);     [OK]
void AnyArray_free(AnyArray_slice *);                                   [OK]

_tc_AnyArray                                                            [OK]
_tc_Any                                                                 [OK]
assert (tc_ANY->kind());                                                [OK]

any <<= AnyArray_forany (AnyArray)                                      [OK]
any >>= AnyArray_forany                                                 [OK]

void operator<<=(Any&, Short);                                          [OK]
void operator<<=(Any&, UShort);                                         [OK]
void operator<<=(Any&, Long);                                           [OK]
void operator<<=(Any&, ULong);                                          [OK]
void operator<<=(Any&, Float);                                          [OK]
void operator<<=(Any&, Double);                                         [OK]
void operator<<=(Any&, LongLong);                                       [OK]
void operator<<=(Any&, ULongLong);                                      [OK]
void operator<<=(Any&, LongDouble);                                     [OK]
void operator<<=(Any&, const Any&);                                     [OK]
void operator<<=(Any&, Any*);                                           [OK]
void operator<<=(Any&, const char*);                                    [OK]
void operator<<=(Any&, const WChar*);                                   [OK]

void operator<<=(from_fixed);                                           [OK]
void operator<<=(from_boolean);                                         [OK]
void operator<<=(from_char);                                            [OK]
void operator<<=(from_wchar);                                           [OK]
void operator<<=(from_octet);                                           [OK]
void operator<<=(from_string);                                          [OK]
void operator<<=(from_wstring);                                         [OK]

any <<= BooleanArray                                                    [OK]
any <<= CharArray                                                       [OK]
any <<= WCharArray                                                      [OK]
any <<= OctetArray                                                      [OK]
any <<= ShortArray                                                      [OK]
any <<= UShortArray                                                     [OK]
any <<= LongArray                                                       [OK]
any <<= ULongArray                                                      [OK]
any <<= LongLongArray                                                   [OK]
any <<= ULongLongArray                                                  [OK]
any <<= FloatArray                                                      [OK]
any <<= DoubleArray                                                     [OK]
any <<= LongDoubleArray                                                 [OK]

Insertion of Enumeration into any type                                  [OK]
Insertion of Object into any type                                       [OK]
Insertion of valuetype into any type                                    [OK]
Insertion of struct into any type                                       [OK]
Insertion of union into any type                                        [OK]
Insertion of sequence into any type                                     [OK]
Insertion of exception into any type                                    [OK]

Boolean operator>>=(const Any&, Short&);                                [OK]
Boolean operator>>=(const Any&, UShort&);                               [OK]
Boolean operator>>=(const Any&, Long&);                                 [OK]
Boolean operator>>=(const Any&, ULong&);                                [OK]
Boolean operator>>=(const Any&, Float&);                                [OK]
Boolean operator>>=(const Any&, Double&);                               [OK]
Boolean operator>>=(const Any&, LongLong&);                             [OK]
Boolean operator>>=(const Any&, ULongLong&);                            [OK]
Boolean operator>>=(const Any&, LongDouble&);                           [OK]
Boolean operator>>=(const Any&, const Any*&);                           [OK]
Boolean operator>>=(const Any&, const char*&);                          [OK]
Boolean operator>>=(const Any&, const WChar*&);                         [OK]

Boolean operator>>=(to_boolean) const;                                  [OK]
Boolean operator>>=(to_char) const;                                     [OK]
Boolean operator>>=(to_wchar) const;                                    [OK]
Boolean operator>>=(to_octet) const;                                    [OK]
Boolean operator>>=(to_object) const;                                   [OK]
Boolean operator>>=(to_string) const;                                   [OK]
Boolean operator>>=(to_wstring) const;                                  [OK]
Boolean operator>>=(to_fixed) const;                                    [OK]
Boolean operator>>=(to_abstract_base) const;                            [ERROR]
Boolean operator>>=(to_value) const;                                    [OK]

any >>= BooleanArray                                                    [OK]
any >>= CharArray                                                       [OK]
any >>= WCharArray                                                      [OK]
any >>= OctetArray                                                      [OK]
any >>= ShortArray                                                      [OK]
any >>= UShortArray                                                     [OK]
any >>= LongArray                                                       [OK]
any >>= ULongArray                                                      [OK]
any >>= LongLongArray                                                   [OK]
any >>= ULongLongArray                                                  [OK]
any >>= FloatArray                                                      [OK]
any >>= DoubleArray                                                     [OK]
any >>= LongDoubleArray                                                 [OK]

Extraction of Enumeration from any type                                 [OK]
Extraction of valuetype from any type                                   [ERROR]
Extraction of struct from any type                                      [OK]
Extraction of union from any type                                       [OK]
Extraction of sequence from any type                                    [OK]
Extraction of exception from any type                                   [OK]

 

Test StructuredTypes
	 
Member Attribute: CORBA::Float FloatType;                       [OK]
Member Attribute: CORBA::Double DoubleType;                     [OK]
Member Attribute: CORBA::LongDouble LongDoubleType;             [OK]
Member Attribute: CORBA::Short ShortType;                       [OK]
Member Attribute: CORBA::Long LongType;                         [OK]
Member Attribute: CORBA::LongLong LongLongType;                 [OK]
Member Attribute: CORBA::UShort UnsignedShortType;              [OK]
Member Attribute: CORBA::ULong UnsignedLongType;                [OK]
Member Attribute: CORBA::ULongLong UnsignedLongLongType;        [OK]
Member Attribute: CORBA::Any AnyType;                           [OK]
Member Attribute: CORBA::Char CharType;                         [OK]
Member Attribute: CORBA::WChar WcharType;                       [OK]
Member Attribute: CORBA::Boolean BooleanType                    [OK]
Member Attribute: CORBA::Octet OctetType;                       [OK]
Member Attribute: FloatArray;                                   [OK]

Pointer to Struct_BasicTypes                                    
Member Attribute: CORBA::Float FloatType;                       [OK]
Member Attribute: CORBA::Double DoubleType;                     [OK]
Member Attribute: CORBA::LongDouble LongDoubleType;             [OK]
Member Attribute: CORBA::Short ShortType;                       [OK]
Member Attribute: CORBA::Long LongType;                         [OK]
Member Attribute: CORBA::LongLong LongLongType;                 [OK]
Member Attribute: CORBA::UShort UnsignedShortType;              [OK]
Member Attribute: CORBA::ULong UnsignedLongType;                [OK]
Member Attribute: CORBA::ULongLong UnsignedLongLongType;        [OK]
Member Attribute: CORBA::Any AnyType;                           [OK]
Member Attribute: CORBA::Char CharType;                         [OK]
Member Attribute: CORBA::WChar WcharType;                       [OK]
Member Attribute: CORBA::Boolean BooleanType                    [OK]
Member Attribute: CORBA::Octet OctetType;                       [OK]
Member Attribute: FloatArray;                                   [OK]

Struct_BasicTypes_var                                           [OK]

Struct_Templates                                                [OK]

Mapping of a Bounded Sequence Type nested in a Struct Type      
void length(CORBA::ULong v);                                    [OK]
CORBA::Float& operator[](CORBA::ULong index);                   [OK]
const CORBA::Float& operator[](CORBA::ULong index) const;       [OK]
CORBA::Float* get_buffer(CORBA::Boolean orphan = false);        [OK]
const CORBA::Float* get_buffer() const;                         [OK]
CORBA::ULong maximum() const {return m_bound;}                  [OK]
CORBA::ULong length() const {return m_length;}                  [OK]
void replace(length, data, release);                            [OK]
CORBA::Boolean release() const {return m_release;}              [OK]
static CORBA::Float* allocbuf();                                [OK]
static void freebuf(CORBA::Float* buf);                         [OK]

Mapping of an unbounded Sequence Type nested in a Struct Type   
void length(CORBA::ULong v);                                    [OK]
CORBA::Float& operator[](CORBA::ULong index);                   [OK]
const CORBA::Float& operator[](CORBA::ULong index) const;       [OK]
CORBA::Float* get_buffer(CORBA::Boolean orphan = false);        [OK]
const CORBA::Float* get_buffer() const;                         [OK]
CORBA::ULong maximum() const {return m_bound;}                  [OK]
CORBA::ULong length() const {return m_length;}                  [OK]
void replace(length, data, release);                            [OK]
CORBA::Boolean release() const {return m_release;}              [OK]
static CORBA::Float* allocbuf();                                [OK]
static void freebuf(CORBA::Float* buf);                         [OK]

Mapping for an unbounded String type in a Struct Type           [OK]
Mapping for a bounded String type in a Struct Type              [OK]

Mapping for an unbounded WString type in a Struct Type          [OK]
Mapping for a bounded WString type in a Struct Type             [OK]

Mapping for nested sequence in a Struct Type                    [OK]
Mapping for array of sequence in a Struct Type                  [OK]
Mapping for Fixed in a Struct Type                              [OK]
Mapping for Typedef struct                                      [OK]
Mapping for Forward declaration struct                          [OK]

Union type with basic types (switch char)                       [OK]
CORBA::Float FloatType() const;                                 [OK]
void FloatType(CORBA::Float);                                   [OK]
CORBA::Double DoubleType() const;                               [OK]
void DoubleType(CORBA::Double);                                 [OK]
CORBA::LongDouble LongDoubleType() const;                       [OK]
void LongDoubleType(CORBA::LongDouble);                         [OK]
CORBA::Short ShortType() const;                                 [OK]
void ShortType(CORBA::Short);                                   [OK]
CORBA::Long LongType() const;                                   [OK]
void LongType(CORBA::Long);                                     [OK]
CORBA::LongLong LongLongType() const;                           [OK]
void LongLongType(CORBA::LongLong);                             [OK]
CORBA::UShort UnsignedShortType() const;                        [OK]
void UnsignedShortType(CORBA::UShort);                          [OK]
CORBA::ULong UnsignedLongType() const;                          [OK]
void UnsignedLongType(CORBA::ULong);                            [OK]
CORBA::ULongLong UnsignedLongLongType() const;                  [OK]
void UnsignedLongLongType(CORBA::ULongLong);                    [OK]
CORBA::Char CharType() const;                                   [OK]
void CharType(CORBA::Char);                                     [OK]
CORBA::WChar WcharType() const;                                 [OK]
void WcharType(CORBA::WChar);                                   [OK]
CORBA::Boolean BooleanType() const;                             [OK]
void BooleanType(CORBA::Boolean);                               [OK]
CORBA::Octet OctetType() const;                                 [OK]
void OctetType(CORBA::Octet);                                   [OK]
CORBA::Any& AnyType();                                          [OK]
void AnyType(const CORBA::Any&);                                [OK]
const ORB_TEST::ArrayFloatType_slice* arrayFloatType() const;   [OK]
ORB_TEST::ArrayFloatType_slice* arrayFloatType();               [OK]
void arrayFloatType(const ORB_TEST::ArrayFloatType);            [OK]
CORBA::Float FloatTypeDefault() const;                          [OK]
void FloatTypeDefault(CORBA::Float);                            [OK]
CORBA::Char _d() const;                                         [OK]
union_BasicTypes._d(charType);                                  [OK]

Pointer to Union type with basic types (switch char)            [OK]
CORBA::Float FloatType() const;                                 [OK]
void FloatType(CORBA::Float);                                   [OK]
CORBA::Double DoubleType() const;                               [OK]
void DoubleType(CORBA::Double);                                 [OK]
CORBA::LongDouble LongDoubleType() const;                       [OK]
void LongDoubleType(CORBA::LongDouble);                         [OK]
CORBA::Short ShortType() const;                                 [OK]
void ShortType(CORBA::Short);                                   [OK]
CORBA::Long LongType() const;                                   [OK]
void LongType(CORBA::Long);                                     [OK]
CORBA::LongLong LongLongType() const;                           [OK]
void LongLongType(CORBA::LongLong);                             [OK]
CORBA::UShort UnsignedShortType() const;                        [OK]
void UnsignedShortType(CORBA::UShort);                          [OK]
CORBA::ULong UnsignedLongType() const;                          [OK]
void UnsignedLongType(CORBA::ULong);                            [OK]
CORBA::ULongLong UnsignedLongLongType() const;                  [OK]
void UnsignedLongLongType(CORBA::ULongLong);                    [OK]
CORBA::Char CharType() const;                                   [OK]
void CharType(CORBA::Char);                                     [OK]
CORBA::WChar WcharType() const;                                 [OK]
void WcharType(CORBA::WChar);                                   [OK]
CORBA::Boolean BooleanType() const;                             [OK]
void BooleanType(CORBA::Boolean);                               [OK]
CORBA::Octet OctetType() const;                                 [OK]
void OctetType(CORBA::Octet);                                   [OK]
CORBA::Any& AnyType();                                          [OK]
void AnyType(const CORBA::Any&);                                [OK]
const ORB_TEST::ArrayFloatType_slice* arrayFloatType() const;   [OK]
ORB_TEST::ArrayFloatType_slice* arrayFloatType();               [OK]
void arrayFloatType(const ORB_TEST::ArrayFloatType);            [OK]
CORBA::Float FloatTypeDefault() const;                          [OK]
void FloatTypeDefault(CORBA::Float);                            [OK]
CORBA::Char _d() const;                                         [OK]
union_BasicTypes._d(charType);                                  [OK]

Mapping for Union type (switch integer)                         [OK]
Mapping for Union type (switch boolean)                         [OK]
Mapping for Union type (switch enum)                            [OK]

Mapping for an Union type with templates                        [OK]

Mapping of a Bounded Sequence Type nested in an Union Type      [OK]

Mapping for an unbounded String type in an Union Type           [OK]
Mapping for a bounded String type in an Union Type              [OK]
Mapping for an unbounded WString type in an Union Type          [OK]
Mapping for a bounded WString type in an Union Type             [OK]

Mapping for nested sequence in a Union Type                     [OK]
Mapping for array of sequence in a Union Type                   [OK]
Mapping for Fixed in a Union Type                               [OK]
Mapping for Typedef Union                                       [OK]
Mapping for Forward declaration Union                           [OK]

Mapping for Enum Type                                           [OK]
Mapping for Enum with typedef                                   [OK]

Mapping for struct with "nested" structured types 
  struct                                                        [OK]
  union                                                         [OK]
  enum                                                          [OK]
Mapping for union with "nested" structured types 
  struct                                                        [OK]
  union                                                         [OK]
  enum                                                          [OK]

Mapping for type codes                                          [OK]



Test TemplateTypes
	 
TemplateType_sequence_any_11 Bounded Sequence                   [OK]
void length(CORBA::ULong v);                                    [OK]
CORBA::Any& operator[](CORBA::ULong index);                     [OK]
const CORBA::Any& operator[](CORBA::ULong index) const;         [OK]
CORBA::Any* get_buffer(CORBA::Boolean orphan = false);          [OK]
const CORBA::Any* get_buffer() const;                           [OK]
CORBA::ULong maximum() const {return m_bound;}                  [OK]
CORBA::ULong length() const {return m_length;}                  [OK]
void replace(length, data, release);                            [OK]
CORBA::Boolean release() const {return m_release;}              [OK]
static CORBA::Any* allocbuf();                                  [OK]
static void freebuf(CORBA::Any* buf);                           [OK]

TemplateType_sequence_any Unbounded Sequence 
void length(CORBA::ULong v);                                    [OK]
CORBA::Any& operator[](CORBA::ULong index);                     [OK]
const CORBA::Any& operator[](CORBA::ULong index) const;         [OK]
CORBA::Any* get_buffer(CORBA::Boolean orphan = false);          [OK]
const CORBA::Any* get_buffer() const;                           [OK]
CORBA::ULong maximum() const {return m_bound;}                  [OK]
CORBA::ULong length() const {return m_length;}                  [OK]
void replace(length, data, release);                            [OK]
CORBA::Boolean release() const {return m_release;}              [OK]
static CORBA::Any* allocbuf();                                  [OK]
static void freebuf(CORBA::Any* buf);                           [OK]

TemplateType_sequence_wchar_18  Bounded Sequence 
void length(CORBA::ULong v);                                    [OK]
CORBA::Any& operator[](CORBA::ULong index);                     [OK]
const CORBA::Any& operator[](CORBA::ULong index) const;         [OK]
CORBA::Any* get_buffer(CORBA::Boolean orphan = false);          [OK]
const CORBA::Any* get_buffer() const;                           [OK]
CORBA::ULong maximum() const {return m_bound;}                  [OK]
CORBA::ULong length() const {return m_length;}                  [OK]
void replace(length, data, release);                            [OK]
CORBA::Boolean release() const {return m_release;}              [OK]
static CORBA::Any* allocbuf();                                  [OK]
static void freebuf(CORBA::Any* buf);                           [OK]

TemplateType_sequence_wchar  Unbounded Sequence 
void length(CORBA::ULong v);                                    [OK]
CORBA::Any& operator[](CORBA::ULong index);                     [OK]
const CORBA::Any& operator[](CORBA::ULong index) const;         [OK]
CORBA::Any* get_buffer(CORBA::Boolean orphan = false);          [OK]
const CORBA::Any* get_buffer() const;                           [OK]
CORBA::ULong maximum() const {return m_bound;}                  [OK]
CORBA::ULong length() const {return m_length;}                  [OK]
void replace(length, data, release);                            [OK]
CORBA::Boolean release() const {return m_release;}              [OK]
static CORBA::Any* allocbuf();                                  [OK]
static void freebuf(CORBA::Any* buf);                           [OK]

TemplateType_sequence_long_double_11  Bounded Sequence 
void length(CORBA::ULong v);                                    [OK]
CORBA::Any& operator[](CORBA::ULong index);                     [OK]
const CORBA::Any& operator[](CORBA::ULong index) const;         [OK]
CORBA::Any* get_buffer(CORBA::Boolean orphan = false);          [OK]
const CORBA::Any* get_buffer() const;                           [OK]
CORBA::ULong maximum() const {return m_bound;}                  [OK]
CORBA::ULong length() const {return m_length;}                  [OK]
void replace(length, data, release);                            [OK]
CORBA::Boolean release() const {return m_release;}              [OK]
static CORBA::Any* allocbuf();                                  [OK]
static void freebuf(CORBA::Any* buf);                           [OK]

TemplateType_sequence_long_double  Unbounded Sequence 
void length(CORBA::ULong v);                                    [OK]
CORBA::Any& operator[](CORBA::ULong index);                     [OK]
const CORBA::Any& operator[](CORBA::ULong index) const;         [OK]
CORBA::Any* get_buffer(CORBA::Boolean orphan = false);          [OK]
const CORBA::Any* get_buffer() const;                           [OK]
CORBA::ULong maximum() const {return m_bound;}                  [OK]
CORBA::ULong length() const {return m_length;}                  [OK]
void replace(length, data, release);                            [OK]
CORBA::Boolean release() const {return m_release;}              [OK]
static CORBA::Any* allocbuf();                                  [OK]
static void freebuf(CORBA::Any* buf);                           [OK]

TemplateType_sequence_double_18  Bounded Sequence 
void length(CORBA::ULong v);                                    [OK]
CORBA::Any& operator[](CORBA::ULong index);                     [OK]
const CORBA::Any& operator[](CORBA::ULong index) const;         [OK]
CORBA::Any* get_buffer(CORBA::Boolean orphan = false);          [OK]
const CORBA::Any* get_buffer() const;                           [OK]
CORBA::ULong maximum() const {return m_bound;}                  [OK]
CORBA::ULong length() const {return m_length;}                  [OK]
void replace(length, data, release);                            [OK]
CORBA::Boolean release() const {return m_release;}              [OK]
static CORBA::Any* allocbuf();                                  [OK]
static void freebuf(CORBA::Any* buf);                           [OK]

TemplateType_sequence_double  Unbounded Sequence 
void length(CORBA::ULong v);                                    [OK]
CORBA::Any& operator[](CORBA::ULong index);                     [OK]
const CORBA::Any& operator[](CORBA::ULong index) const;         [OK]
CORBA::Any* get_buffer(CORBA::Boolean orphan = false);          [OK]
const CORBA::Any* get_buffer() const;                           [OK]
CORBA::ULong maximum() const {return m_bound;}                  [OK]
CORBA::ULong length() const {return m_length;}                  [OK]
void replace(length, data, release);                            [OK]
CORBA::Boolean release() const {return m_release;}              [OK]
static CORBA::Any* allocbuf();                                  [OK]
static void freebuf(CORBA::Any* buf);                           [OK]

TemplateType_sequence_float_11  Bounded Sequence 
void length(CORBA::ULong v);                                    [OK]
CORBA::Any& operator[](CORBA::ULong index);                     [OK]
const CORBA::Any& operator[](CORBA::ULong index) const;         [OK]
CORBA::Any* get_buffer(CORBA::Boolean orphan = false);          [OK]
const CORBA::Any* get_buffer() const;                           [OK]
CORBA::ULong maximum() const {return m_bound;}                  [OK]
CORBA::ULong length() const {return m_length;}                  [OK]
void replace(length, data, release);                            [OK]
CORBA::Boolean release() const {return m_release;}              [OK]
static CORBA::Any* allocbuf();                                  [OK]
static void freebuf(CORBA::Any* buf);                           [OK]

TemplateType_sequence_float  Unbounded Sequence 
void length(CORBA::ULong v);                                    [OK]
CORBA::Any& operator[](CORBA::ULong index);                     [OK]
const CORBA::Any& operator[](CORBA::ULong index) const;         [OK]
CORBA::Any* get_buffer(CORBA::Boolean orphan = false);          [OK]
const CORBA::Any* get_buffer() const;                           [OK]
CORBA::ULong maximum() const {return m_bound;}                  [OK]
CORBA::ULong length() const {return m_length;}                  [OK]
void replace(length, data, release);                            [OK]
CORBA::Boolean release() const {return m_release;}              [OK]
static CORBA::Any* allocbuf();                                  [OK]
static void freebuf(CORBA::Any* buf);                           [OK]

TemplateType_sequence_long_18  Bounded Sequence 
void length(CORBA::ULong v);                                    [OK]
CORBA::Any& operator[](CORBA::ULong index);                     [OK]
const CORBA::Any& operator[](CORBA::ULong index) const;         [OK]
CORBA::Any* get_buffer(CORBA::Boolean orphan = false);          [OK]
const CORBA::Any* get_buffer() const;                           [OK]
CORBA::ULong maximum() const {return m_bound;}                  [OK]
CORBA::ULong length() const {return m_length;}                  [OK]
void replace(length, data, release);                            [OK]
CORBA::Boolean release() const {return m_release;}              [OK]
static CORBA::Any* allocbuf();                                  [OK]
static void freebuf(CORBA::Any* buf);                           [OK]

TemplateType_sequence_long  Unbounded Sequence 
void length(CORBA::ULong v);                                    [OK]
CORBA::Any& operator[](CORBA::ULong index);                     [OK]
const CORBA::Any& operator[](CORBA::ULong index) const;         [OK]
CORBA::Any* get_buffer(CORBA::Boolean orphan = false);          [OK]
const CORBA::Any* get_buffer() const;                           [OK]
CORBA::ULong maximum() const {return m_bound;}                  [OK]
CORBA::ULong length() const {return m_length;}                  [OK]
void replace(length, data, release);                            [OK]
CORBA::Boolean release() const {return m_release;}              [OK]
static CORBA::Any* allocbuf();                                  [OK]
static void freebuf(CORBA::Any* buf);                           [OK]

TemplateType_sequence_short  Unbounded Sequence 
void length(CORBA::ULong v);                                    [OK]
CORBA::Any& operator[](CORBA::ULong index);                     [OK]
const CORBA::Any& operator[](CORBA::ULong index) const;         [OK]
CORBA::Any* get_buffer(CORBA::Boolean orphan = false);          [OK]
const CORBA::Any* get_buffer() const;                           [OK]
CORBA::ULong maximum() const {return m_bound;}                  [OK]
CORBA::ULong length() const {return m_length;}                  [OK]
void replace(length, data, release);                            [OK]
CORBA::Boolean release() const {return m_release;}              [OK]
static CORBA::Any* allocbuf();                                  [OK]
static void freebuf(CORBA::Any* buf);                           [OK]

TemplateType_sequence_short_11  Bounded Sequence 
void length(CORBA::ULong v);                                    [OK]
CORBA::Any& operator[](CORBA::ULong index);                     [OK]
const CORBA::Any& operator[](CORBA::ULong index) const;         [OK]
CORBA::Any* get_buffer(CORBA::Boolean orphan = false);          [OK]
const CORBA::Any* get_buffer() const;                           [OK]
CORBA::ULong maximum() const {return m_bound;}                  [OK]
CORBA::ULong length() const {return m_length;}                  [OK]
void replace(length, data, release);                            [OK]
CORBA::Boolean release() const {return m_release;}              [OK]
static CORBA::Any* allocbuf();                                  [OK]
static void freebuf(CORBA::Any* buf);                           [OK]

TemplateType_sequence_unsigned_long  Unbounded Sequence 
void length(CORBA::ULong v);                                    [OK]
CORBA::Any& operator[](CORBA::ULong index);                     [OK]
const CORBA::Any& operator[](CORBA::ULong index) const;         [OK]
CORBA::Any* get_buffer(CORBA::Boolean orphan = false);          [OK]
const CORBA::Any* get_buffer() const;                           [OK]
CORBA::ULong maximum() const {return m_bound;}                  [OK]
CORBA::ULong length() const {return m_length;}                  [OK]
void replace(length, data, release);                            [OK]
CORBA::Boolean release() const {return m_release;}              [OK]
static CORBA::Any* allocbuf();                                  [OK]
static void freebuf(CORBA::Any* buf);                           [OK]

TemplateType_sequence_unsigned_long_18  Bounded Sequence 
void length(CORBA::ULong v);                                    [OK]
CORBA::Any& operator[](CORBA::ULong index);                     [OK]
const CORBA::Any& operator[](CORBA::ULong index) const;         [OK]
CORBA::Any* get_buffer(CORBA::Boolean orphan = false);          [OK]
const CORBA::Any* get_buffer() const;                           [OK]
CORBA::ULong maximum() const {return m_bound;}                  [OK]
CORBA::ULong length() const {return m_length;}                  [OK]
void replace(length, data, release);                            [OK]
CORBA::Boolean release() const {return m_release;}              [OK]
static CORBA::Any* allocbuf();                                  [OK]
static void freebuf(CORBA::Any* buf);                           [OK]

TemplateType_sequence_unsigned_short  Unbounded Sequence 
void length(CORBA::ULong v);                                    [OK]
CORBA::Any& operator[](CORBA::ULong index);                     [OK]
const CORBA::Any& operator[](CORBA::ULong index) const;         [OK]
CORBA::Any* get_buffer(CORBA::Boolean orphan = false);          [OK]
const CORBA::Any* get_buffer() const;                           [OK]
CORBA::ULong maximum() const {return m_bound;}                  [OK]
CORBA::ULong length() const {return m_length;}                  [OK]
void replace(length, data, release);                            [OK]
CORBA::Boolean release() const {return m_release;}              [OK]
static CORBA::Any* allocbuf();                                  [OK]
static void freebuf(CORBA::Any* buf);                           [OK]

TemplateType_sequence_unsigned_short_11  Bounded Sequence 
void length(CORBA::ULong v);                                    [OK]
CORBA::Any& operator[](CORBA::ULong index);                     [OK]
const CORBA::Any& operator[](CORBA::ULong index) const;         [OK]
CORBA::Any* get_buffer(CORBA::Boolean orphan = false);          [OK]
const CORBA::Any* get_buffer() const;                           [OK]
CORBA::ULong maximum() const {return m_bound;}                  [OK]
CORBA::ULong length() const {return m_length;}                  [OK]
void replace(length, data, release);                            [OK]
CORBA::Boolean release() const {return m_release;}              [OK]
static CORBA::Any* allocbuf();                                  [OK]
static void freebuf(CORBA::Any* buf);                           [OK]

TemplateType_sequence_char  Unbounded Sequence 
void length(CORBA::ULong v);                                    [OK]
CORBA::Any& operator[](CORBA::ULong index);                     [OK]
const CORBA::Any& operator[](CORBA::ULong index) const;         [OK]
CORBA::Any* get_buffer(CORBA::Boolean orphan = false);          [OK]
const CORBA::Any* get_buffer() const;                           [OK]
CORBA::ULong maximum() const {return m_bound;}                  [OK]
CORBA::ULong length() const {return m_length;}                  [OK]
void replace(length, data, release);                            [OK]
CORBA::Boolean release() const {return m_release;}              [OK]
static CORBA::Any* allocbuf();                                  [OK]
static void freebuf(CORBA::Any* buf);                           [OK]

TemplateType_sequence_char_18  Bounded Sequence 
void length(CORBA::ULong v);                                    [OK]
CORBA::Any& operator[](CORBA::ULong index);                     [OK]
const CORBA::Any& operator[](CORBA::ULong index) const;         [OK]
CORBA::Any* get_buffer(CORBA::Boolean orphan = false);          [OK]
const CORBA::Any* get_buffer() const;                           [OK]
CORBA::ULong maximum() const {return m_bound;}                  [OK]
CORBA::ULong length() const {return m_length;}                  [OK]
void replace(length, data, release);                            [OK]
CORBA::Boolean release() const {return m_release;}              [OK]
static CORBA::Any* allocbuf();                                  [OK]
static void freebuf(CORBA::Any* buf);                           [OK]

TemplateType_sequence_boolean  Unbounded Sequence 
void length(CORBA::ULong v);                                    [OK]
CORBA::Any& operator[](CORBA::ULong index);                     [OK]
const CORBA::Any& operator[](CORBA::ULong index) const;         [OK]
CORBA::Any* get_buffer(CORBA::Boolean orphan = false);          [OK]
const CORBA::Any* get_buffer() const;                           [OK]
CORBA::ULong maximum() const {return m_bound;}                  [OK]
CORBA::ULong length() const {return m_length;}                  [OK]
void replace(length, data, release);                            [OK]
CORBA::Boolean release() const {return m_release;}              [OK]
static CORBA::Any* allocbuf();                                  [OK]
static void freebuf(CORBA::Any* buf);                           [OK]

TemplateType_sequence_boolean_11 Bounded Sequence 
void length(CORBA::ULong v);                                    [OK]
CORBA::Any& operator[](CORBA::ULong index);                     [OK]
const CORBA::Any& operator[](CORBA::ULong index) const;         [OK]
CORBA::Any* get_buffer(CORBA::Boolean orphan = false);          [OK]
const CORBA::Any* get_buffer() const;                           [OK]
CORBA::ULong maximum() const {return m_bound;}                  [OK]
CORBA::ULong length() const {return m_length;}                  [OK]
void replace(length, data, release);                            [OK]
CORBA::Boolean release() const {return m_release;}              [OK]
static CORBA::Any* allocbuf();                                  [OK]
static void freebuf(CORBA::Any* buf);                           [OK]

TemplateType_sequence_octet Unbounded Sequence 
void length(CORBA::ULong v);                                    [OK]
CORBA::Any& operator[](CORBA::ULong index);                     [OK]
const CORBA::Any& operator[](CORBA::ULong index) const;         [OK]
CORBA::Any* get_buffer(CORBA::Boolean orphan = false);          [OK]
const CORBA::Any* get_buffer() const;                           [OK]
CORBA::ULong maximum() const {return m_bound;}                  [OK]
CORBA::ULong length() const {return m_length;}                  [OK]
void replace(length, data, release);                            [OK]
CORBA::Boolean release() const {return m_release;}              [OK]
static CORBA::Any* allocbuf();                                  [OK]
static void freebuf(CORBA::Any* buf);                           [OK]

TemplateType_sequence_octet_18  Bounded Sequence 
void length(CORBA::ULong v);                                    [OK]
CORBA::Any& operator[](CORBA::ULong index);                     [OK]
const CORBA::Any& operator[](CORBA::ULong index) const;         [OK]
CORBA::Any* get_buffer(CORBA::Boolean orphan = false);          [OK]
const CORBA::Any* get_buffer() const;                           [OK]
CORBA::ULong maximum() const {return m_bound;}                  [OK]
CORBA::ULong length() const {return m_length;}                  [OK]
void replace(length, data, release);                            [OK]
CORBA::Boolean release() const {return m_release;}              [OK]
static CORBA::Any* allocbuf();                                  [OK]
static void freebuf(CORBA::Any* buf);                           [OK]

TemplateType_sequence_string_11  Bounded Sequence 
void length(CORBA::ULong v);                                    [OK]
CORBA::Any& operator[](CORBA::ULong index);                     [OK]
const CORBA::Any& operator[](CORBA::ULong index) const;         [OK]
CORBA::Any* get_buffer(CORBA::Boolean orphan = false);          [OK]
const CORBA::Any* get_buffer() const;                           [OK]
CORBA::ULong maximum() const {return m_bound;}                  [OK]
CORBA::ULong length() const {return m_length;}                  [OK]
void replace(length, data, release);                            [OK]
CORBA::Boolean release() const {return m_release;}              [OK]
static CORBA::Any* allocbuf();                                  [OK]
static void freebuf(CORBA::Any* buf);                           [OK]

TemplateType_sequence_string_bounded_18  Bounded Sequence 
void length(CORBA::ULong v);                                    [OK]
CORBA::Any& operator[](CORBA::ULong index);                     [OK]
const CORBA::Any& operator[](CORBA::ULong index) const;         [OK]
CORBA::Any* get_buffer(CORBA::Boolean orphan = false);          [OK]
const CORBA::Any* get_buffer() const;                           [OK]
CORBA::ULong maximum() const {return m_bound;}                  [OK]
CORBA::ULong length() const {return m_length;}                  [OK]
void replace(length, data, release);                            [OK]
CORBA::Boolean release() const {return m_release;}              [OK]
static CORBA::Any* allocbuf();                                  [OK]
static void freebuf(CORBA::Any* buf);                           [OK]

Template_sequence_string  Unbounded Sequence 
void length(CORBA::ULong v);                                    [OK]
CORBA::Any& operator[](CORBA::ULong index);                     [OK]
const CORBA::Any& operator[](CORBA::ULong index) const;         [OK]
CORBA::Any* get_buffer(CORBA::Boolean orphan = false);          [OK]
const CORBA::Any* get_buffer() const;                           [OK]
CORBA::ULong maximum() const {return m_bound;}                  [OK]
CORBA::ULong length() const {return m_length;}                  [OK]
void replace(length, data, release);                            [OK]
CORBA::Boolean release() const {return m_release;}              [OK]
static CORBA::Any* allocbuf();                                  [OK]
static void freebuf(CORBA::Any* buf);                           [OK]

Template_sequence_string_bounded  Unbounded Sequence 
void length(CORBA::ULong v);                                    [OK]
CORBA::Any& operator[](CORBA::ULong index);                     [OK]
const CORBA::Any& operator[](CORBA::ULong index) const;         [OK]
CORBA::Any* get_buffer(CORBA::Boolean orphan = false);          [OK]
const CORBA::Any* get_buffer() const;                           [OK]
CORBA::ULong maximum() const {return m_bound;}                  [OK]
CORBA::ULong length() const {return m_length;}                  [OK]
void replace(length, data, release);                            [OK]
CORBA::Boolean release() const {return m_release;}              [OK]
static CORBA::Any* allocbuf();                                  [OK]
static void freebuf(CORBA::Any* buf);                           [OK]

TemplateType_string                                             [OK]
char* TemplateType_string_alloc(CORBA::ULong len);              [OK]
char* TemplateType_string_dup(const char* str);                 [OK]
void TemplateType_string_free(char* str);                       [OK]

TemplateType_string_bounded                                     [OK]
char* TemplateType_string_bounded_alloc(CORBA::ULong len);      [OK]
char* TemplateType_string_bounded_dup(const char* str);         [OK]
void TemplateType_string_bounded_free(char* str);               [OK]

TemplateType_wstring                                            [OK]
CORBA::WChar* TemplateType_wstring_alloc(CORBA::ULong len);     [OK]
CORBA::WChar* TemplateType_wstring_dup(wstr);                   [OK]
void TemplateType_wstring_free(CORBA::WChar* wstr);             [OK]

TemplateType_wstring_bounded                                    [OK]
CORBA::WChar* TemplateType_wstring_bounded_alloc(len);          [OK]
CORBA::WChar* TemplateType_wstring_bounded_dup(wstr);           [OK]
void TemplateType_wstring_bounded_free(CORBA::WChar* wstr);     [OK]

TemplateType_fixedType;                                         [OK]
Nested sequence                                                 [OK]
Array (unidimensional and bidimensional) of a Sequence Type     [OK]
Type Codes                                                      [OK]
Sequence T_var declarations                                     [OK]
String T_var declarations                                       [OK]
WString T_var declarations                                      [OK]


Test Native
	 
Visual comprobation: 
no support code has been generated for native type              [OK]

Test Exceptions

Constructor 1 for empty user exception : Exception_empty();     [OK]
Constructor 2 for empty user exception : Exception_empty(ex);   [OK]
Exception_empty_var                                             [OK]
void _raise() const;                                            [OK]
const char* _name() const;                                      [OK]
const char* _rep_id() const;                                    [OK]
static ExceptionType* _downcast(CORBA::Exception* e);           [OK]
static const ExceptionType* _downcast(e);                       [OK]

UserException with string: Exception_string()                   [OK]
UserException with string: Exception_string(Exception_string)   [OK]
UserException with string: Exception_string(String_var)         [OK]


Test Interfaces
	 
Mapping of test_ref                                             [OK]
Mapping of test_ptr                                             [OK]
Mapping of operator "="                                         [OK]

test_ptr->opVoid()                                              [OK]
test_ptr->opOneway(const char* param)                           [OK]
test_ref->opReturnFloat()                                       [OK]
test_ref->opReturnDouble()                                      [OK]
test_ref->opReturnLongDouble()                                  [OK]
test_ref->opReturnChar()                                        [OK]
test_ref->opReturnWchar()                                       [OK]
test_ref->opReturnBoolean()                                     [OK]
test_ref->opReturnOctet()                                       [OK]
test_ref->opReturnShort()                                       [OK]
test_ref->opReturnLong()                                        [OK]
test_ref->opReturnUShort()                                      [OK]
test_ref->opReturnUShort()                                      [OK]
test_ref->opReturnULong()                                       [OK]
test_ref->opReturnULLong()                                      [OK]
test_ref->opParamFloat(a, b, c), in parameter                   [OK]
test_ref->opParamFloat(a, b, c), out parameter                  [OK]
test_ref->opParamFloat(a, b, c), inout parameter                [OK]
test_ref->opParamDouble(a, b, c), in parameter                  [OK]
test_ref->opParamDouble(a, b, c), out parameter                 [OK]
test_ref->opParamDouble(a, b, c), inout parameter               [OK]
test_ref->opParamLongDouble(a, b, c), in parameter              [OK]
test_ref->opParamLongDouble(a, b, c), out parameter             [OK]
test_ref->opParamLongDouble(a, b, c), inout parameter           [OK]
test_ref->opParamChar(a, b, c), in parameter                    [OK]
test_ref->opParamChar(a, b, c), out parameter                   [OK]
test_ref->opParamChar(a, b, c), inout parameter                 [OK]
test_ref->opParamWChar(a, b, c), in parameter                   [OK]
test_ref->opParamWChar(a, b, c), out parameter                  [OK]
test_ref->opParamWChar(a, b, c), inout parameter                [OK]
test_ref->opParamBoolean(a, b,  c), in parameter                [OK]
test_ref->opParamBoolean(a, b,  c), out parameter               [OK]
test_ref->opParamBoolean(a, b,  c), inout parameter             [OK]
test_ref->opParamOctet( a,  b, c), in parameter                 [OK]
test_ref->opParamOctet( a,  b, c), out parameter                [OK]
test_ref->opParamOctet( a,  b,  c), inout parameter             [OK]
test_ref->opParamShort( a,  b,  c), in parameter                [OK]
test_ref->opParamShort( a,  b,  c), out parameter               [OK]
test_ref->opParamShort( a,  b,  c), inout parameter             [OK]
test_ref->opParamLong( a,  b,  c), in parameter                 [OK]
test_ref->opParamLong( a,  b,  c), out parameter                [OK]
test_ref->opParamLong( a,  b,  c), inout parameter              [OK]
test_ref->opParamLongLong( a, b, c), in parameter               [OK]
test_ref->opParamLongLong( a, b, c), out parameter              [OK]
test_ref->opParamLongLong( a, b, c), inout parameter            [OK]
test_ref->opParamUShort(a, b, c), in parameter                  [OK]
test_ref->opParamUShort(a, b, c), out parameter                 [OK]
test_ref->opParamUShort(a, b, c), inout parameter               [OK]
test_ref->opParamULong(a, b, c), in parameter                   [OK]
test_ref->opParamULong(a, b, c), out parameter                  [OK]
test_ref->opParamULong(a, b, c), inout parameter                [OK]
test_ref->opParamULongLong(a, b, c), in parameter               [OK]
test_ref->opParamULongLong(a, b, c), out parameter              [OK]
test_ref->opParamULongLong(a, b, c), inout parameter            [OK]
test_ref->opParamStringIn(a, b), in bounded string parameter    [OK]
test_ref->opParamStringIn(a, b), in unbounded string parameter  [OK]

[Mapping for Attributes] get/set ops for float attribute (x2)   [OK]
[Interfaces] Mapping of base interface: _ptr                    [OK]
[Interfaces] Mapping of base interface: _var                    [OK]
[Interfaces] Mapping of derived interface: _ptr                 [OK]
[Interfaces] Mapping of derived interface: _var                 [OK]
[Interfaces] Object reference operation: _narrow                [OK]
[Interfaces] Object reference operation: is_nil                 [OK]
[Interfaces] Object reference operation: release                [OK]
[Interfaces] Object reference operation: _duplicate             [OK]
[Interfaces] Object reference operation: _nil()                 [OK]
[Interfaces] Object reference Out Parameter (x5)                [OK]
[Interfaces] Object reference _var (x9)                         [OK]
[Abstract interface] Declarations (x4)                          [OK]
[Abstract interface] _is_nil(AbstractBase_ptr)                  [OK]
[Abstract interface] release (AbstractBase_ptr)                 [OK]
[Abstract interface] _narrow                                    [OK]
[Abstract interfaces] _duplicate                                [OK]
[Abstract interface] _nil()                                     [OK]


Test Values
	 
Regular Valuetype with Basic Types                              [OK]

Regular Valuetype with constant Basic Types                     [OK]
static const CORBA::Float FloatType;                            [OK]

Regular Valuetype with an exception                             [OK]
Constructor 1 for empty user exception : Exception_empty();     [OK]
Constructor 2 for empty user exception : Exception_empty(Ex);   [OK]
Exception_empty_var                                             [OK]
void _raise() const;                                            [OK]
const char* _name() const;                                      [OK]
const char* _rep_id() const;                                    [OK]

Regular Valuetype with a struct type                            [OK]
const ORB_TEST::typeStruct& value_struct()                      [OK]
ORB_TEST::typeStruct& value_struct()                            [OK]
void value_struct(const ORB_TEST::typeStruct&)                  [OK]

Regular Valuetype with a union type                             [OK]
const ORB_TEST::typeUnion& value_union()                        [OK]
ORB_TEST::typeUnion& value_union()                              [OK]
void value_union(const ORB_TEST::typeUnion&)                    [OK]

Regular Valuetype with an enum type                             [OK]
ORB_TEST::typeEnum value_enum()                                 [OK]
void value_enum(ORB_TEST::typeEnum)                             [OK]

Regular Valuetype with a sequence type                          [OK]
const ORB_TEST::template_float& value_sequence()                [OK]
ORB_TEST::template_float& value_sequence()                      [OK]
void value_sequence(const ORB_TEST::template_float&)            [OK]

Regular Valuetype with a string type                            [OK]
const char* template_string()                                   [OK]
void template_string(char*)                                     [OK]
void template_string(const CORBA::String_var&)                  [OK]

Regular Valuetype with a wstring type                           [OK]
const CORBA::WChar* template_wstring() const                    [OK]
void template_wstring(CORBA::WChar*)                            [OK]
void template_wstring(const CORBA::WString_var&)                [OK]

Regular Valuetype with a fixed type                             [OK]
const CORBA::Fixed& template_fixed()                            [OK]
CORBA::Fixed& template_fixed()                                  [OK]
void template_fixed(const CORBA::Fixed&)                        [OK]

Forward Valuetype                                               [OK]

Typecodes (x10)                                                 [OK]



* CORBA CORE (CORBA 2.6 - Chapter 4)
------------------------------------


·Functional Tests
=================

Test Case CORBA_CORE
--------------------
Test ORBInterface
	 
id (x 1)                                                        [OK]
object_to_string (x 1)                                          [OK]
string_to_object (x 2)                                          [OK]
create_list (x 3)                                               [OK]
create_operation_list (x 1)                                     [UNEXPECTED_EXCEPTION]
create_named_value (x 4)                                        [OK]
create_exception_list (x 3)                                     [OK]
create_context_list (x 3)                                       [OK]
get_default_context (x 2)                                       [OK]
create_environment (x 0)                                        [ERROR]
send_multiple_requests_oneway (x 0)                             [OK]
send_multiple_requests_deferred (x 0)                           [OK]
poll_next_response (x 0)                                        [OK]
get_next_response (x 0)                                         [OK]
get_service_information (x 1)                                   [ERROR]
list_initial_services (x 44)                                    [OK]

resolve_initial_references (x 18)                               [OK]
create_struct_tc (x 4)                                          [OK]
create_union_tc (x 4)                                           [OK]
create_enum_tc (x 4)                                            [OK]
create_alias_tc (x 4)                                           [OK]
create_exception_tc (x 4)                                       [OK]
create_interface_tc (x 4)                                       [OK]
create_string_tc (x 4)                                          [OK]
create_wstring_tc (x 4)                                         [OK]
create_fixed_tc (x 4)                                           [OK]
create_sequence_tc (x 8)                                        [OK]
create_recursive_sequence_tc (x 0)                              [OK]
create_array_tc (x 4)                                           [OK]
create_value_tc (x 4)                                           [OK]
create_value_box_tc (x 4)                                       [OK]
create_native_tc (x 4)                                          [OK]
create_recursive_tc (x 3)                                       [OK]
create_abstract_interface_tc (x 4)                              [OK]
create_local_interface_tc (x 4)                                 [OK]
work_pending (x 2)                                              [ERROR]
perform_work (x 1)                                              [ERROR]
run (x 3)                                                       [OK]
shutdown (x 1)                                                  [ERROR]
destroy (x 1)                                                   [ERROR]
create_policy (x 5)                                             [OK]
register_lookup_unregister_value_factory (x 3)                  [OK]
register_initial_reference (x 1)                                [OK]


Test ObjectOperations

get_interface (x 1)                                             [OK]
get_implementation (x 0)                                        [OK]
is_nil (x 2)                                                    [OK]
duplicate (x 3)                                                 [OK]
release (x 1)                                                   [OK]
is_a (x 1)                                                      [OK]
non_existent (x 2)                                              [OK]
is_equivalent (x 2)                                             [OK]
hash (x 2)                                                      [ERROR]
_request (x 3)                                                  [OK]
create_request (x 5)                                            [OK]
create_request_alt (x 5)                                        [OK]
get_policy (x 4)                                                [OK]
get_domain_managers (x 1)                                       [ERROR]
get_set_policy_overrides (x 6)                                  [OK]
get_client_policy (x 1)                                         [ERROR]
validate_connection (x 2)                                       [ERROR]


Test Context

context_name (x 1)                                              [ERROR]
parent (x 0)                                                    [OK]
create_child (x 0)                                              [OK]
get_set_values (x 0)                                            [OK]
delete_values (x 0)                                             [OK]


Test Typecodes

equal (x 2)                                                     [OK]
equivalent (x 2)                                                [OK]
kind (x 1)                                                      [OK]
get_compact_typecode (x 5)                                      [OK]
id (x 0)                                                        [OK]
name (x 2)                                                      [ERROR]
member_count (x 1)                                              [OK]
member_name (x 2)                                               [ERROR]
member_type (x 2)                                               [OK]
member_label (x 2)                                              [OK]
discriminator_type (x 2)                                        [OK]
default_index (x 3)                                             [OK]
length (x 2)                                                    [OK]
content_type (x 2)                                              [OK]
fixed_digits (x 2)                                              [OK]
fixed_scale (x 2)                                               [OK]
member_visibility (x 3)                                         [OK]
type_modifier (x 2)                                             [OK]
concrete_base_type (x 2)                                        [OK]
                   

Test Exceptions

UNKNOWN (x 5)                                                   [OK]
BAD_PARAM (x 5)                                                 [OK]
NO_MEMORY (x 5)                                                 [OK]
IMP_LIMIT (x 5)                                                 [OK]
COMM_FAILURE (x 5)                                              [OK]
INV_OBJREF (x 5)                                                [OK]
NO_PERMISSION (x 5)                                             [OK]
INTERNAL (x 5)                                                  [OK]
MARSHAL (x 5)                                                   [OK]
INITIALIZE (x 5)                                                [OK]
NO_IMPLEMENT (x 5)                                              [OK]
BAD_TYPECODE (x 5)                                              [OK]
BAD_OPERATION (x 5)                                             [OK]
NO_RESOURCES (x 5)                                              [OK]
NO_RESPONSE (x 5)                                               [OK]
PERSIST_STORE (x 5)                                             [OK]
BAD_INV_ORDER (x 5)                                             [OK]
TRANSIENT (x 5)                                                 [OK]
FREE_MEM (x 5)                                                  [OK]
INV_IDENT (x 5)                                                 [OK]
INV_FLAG (x 5)                                                  [OK]
INTF_REPOS (x 5)                                                [OK]
BAD_CONTEXT (x 5)                                               [OK]
OBJ_ADAPTER (x 5)                                               [OK]
DATA_CONVERSION (x 5)                                           [OK]
OBJECT_NOT_EXIST (x 5)                                          [OK]
TRANSACTION_REQUIRED (x 5)                                      [OK]
TRANSACTION_ROLLEDBACK (x 5)                                    [OK]
INVALID_TRANSACTION (x 5)                                       [OK]
INV_POLICY (x 5)                                                [OK]
CODESET_INCOMPATIBLE (x 1)                                      [OK]
REBIND (x 1)                                                    [OK]
TIMEOUT (x 5)                                                   [OK]
TRANSACTION_UNAVAILABLE (x 1)                                   [OK]
TRANSACTION_MODE (x 1)                                          [OK]
BAD_QOS (x 1)                                                   [OK]



·Structural Tests
=================

Test Case OrbInterface
----------------------

ORBId id()                                                      [OK]
char* object_to_string(Object_ptr obj)                          [OK]
Object_ptr string_to_object(const char* str)                    [OK]
void create_list(Long count, NVList_out new_list)               [OK]
void create_operation_list(oper, new_list)                      [OK]
void get_default_context(Context_out ctx)                       [OK]
void send_multiple_requests_oneway(const RequestSeq& req)       [OK]
void send_multiple_requests_deferred(const RequestSeq& req)     [OK]
Boolean poll_next_response()                                    [OK]
void get_next_response(Request_out req)                         [OK]
Boolean get_service_information(service_type,  service_info)    [OK]
ObjectIdList_ptr list_initial_services()                        [OK]
Object_ptr resolve_initial_references(const char *identifier)   [OK]
TypeCode_ptr create_struct_tc(id, name, members)                [OK]
TypeCode_ptr create_union_tc(id, name, discr_type, members)     [OK]
TypeCode_ptr create_enum_tc(id, name, members)                  [OK]
TypeCode_ptr create_alias_tc(id, name, original_type)           [OK]
TypeCode_ptr create_exception_tc(id, name, members)             [OK]
TypeCode_ptr create_interface_tc(id, name)                      [OK]
TypeCode_ptr create_string_tc(ULong bound)                      [OK]
TypeCode_ptr create_wstring_tc(ULong bound)                     [OK]
TypeCode_ptr create_fixed_tc(UShort digits, Short scale)        [OK]
TypeCode_ptr create_sequence_tc(ULong bound, element_type)      [OK]
TypeCode_ptr create_recursive_sequence_tc(bound, offset)        [OK] 
TypeCode_ptr create_array_tc(length, element_type)              [OK]
TypeCode_ptr create_value_tc(id, name, type_modifier, c_base)   [OK] 
TypeCode_ptr create_value_box_tc(id, name, boxed_type)          [OK]
TypeCode_ptr create_native_tc(const char* id, const char* name) [OK]
TypeCode_ptr create_recursive_tc(const char* id)                [OK]
TypeCode_ptr create_abstract_interface_tc(id, name)             [OK]
TypeCode_ptr create_local_interface_tc(id, name)                [OK]
Boolean work_pending()                                          [OK]
void perform_work()                                             [OK]
void shutdown(Boolean wait_for_completion)                      [OK]
void run()                                                      [OK]
void destroy()                                                  [OK]
Policy_ptr create_policy(PolicyType type, const Any& val)       [OK]
ValueFactory register_value_factory(id, factory)                [OK]
void unregister_value_factory(const char* id)                   [OK]
ValueFactory lookup_value_factory(const char* id)               [OK]
void register_initial_reference( object_name, object)           [OK]


Test Case ObjectOperations
--------------------------

Test Object 

InterfaceDef_ptr _get_interface()                               [OK] 
Boolean _is_a(const char* logical_type_id)                      [OK] 
Boolean _non_existent()                                         [OK] 
Boolean _is_equivalent(Object_ptr other_object)                 [OK] 
ULong _hash(ULong maximum)                                      [OK] 
void _create_request(ctx, *op, arg_list, rest, req, req_flags)  [OK] 
Request_ptr _request(const char* operation)                     [OK] 
Policy_ptr _get_policy(PolicyType policy_type)                  [OK] 
DomainManagerList* _get_domain_managers()                       [OK] 
Object_ptr _set_policy_overrides(policies, set_or_add)          [OK] 
Policy_ptr _get_client_policy(PolicyType policy_type)           [OK] 
PolicyList_ptr _get_policy_overrides(types)                     [OK] 
Boolean _validate_connection(inconsistent_policies )            [OK] 
static Object_ptr _duplicate(Object_ptr obj)                    [OK]
static Object_ptr _nil()                                        [OK]


Test Case Context
-----------------

void set_one_value(const char* prop_name, const Any& value)     [OK]
void set_values(NVList_ptr values)                              [OK]
void get_values(start_scope, op_flags, prop_name, values)       [OK]
void delete_values(const char* prop_name)                       [OK]
void create_child(const char* ctx_name, Context_out child_ctx)  [OK] 
const char *context_name()  const                               [OK]
Context_ptr parent()  const                                     [OK]


Test Case Typecodes
-------------------

Boolean equal(TypeCode_ptr) const                               [OK]
Boolean equivalent(TypeCode_ptr) const                          [OK]
TypeCode_ptr get_compact_typecode() const                       [OK]
TCKind kind() const                                             [OK]
const char* id() const                                          [OK]
const char* name() const                                        [OK]
ULong member_count() const                                      [OK]
const char* member_name(ULong index) const                      [OK]
TypeCode_ptr member_type(ULong index) const                     [OK]
Any *member_label(ULong index) const                            [OK]
TypeCode_ptr discriminator_type() const                         [OK]
Long default_index() const                                      [OK]
ULong length() const                                            [OK]
TypeCode_ptr content_type() const                               [OK]
UShort fixed_digits() const                                     [OK]
Short fixed_scale() const                                       [OK]
Visibility member_visibility(ULong index) const                 [OK]
ValueModifier type_modifier() const                             [OK]
TypeCode_ptr concrete_base_type() const                         [OK]


Test Case Exceptions
--------------------

UNKNOWN                                                         [OK]
BAD_PARAM                                                       [OK]
NO_MEMORY                                                       [OK]
IMP_LIMIT                                                       [OK]
COMM_FAILURE                                                    [OK]
INV_OBJREF                                                      [OK]
NO_PERMISSION                                                   [OK]
INTERNAL                                                        [OK]
MARSHAL                                                         [OK]
INITIALIZE                                                      [OK]
NO_IMPLEMENT                                                    [OK]
BAD_TYPECODE                                                    [OK]
BAD_OPERATION                                                   [OK]
NO_RESOURCES                                                    [OK]
NO_RESPONSE                                                     [OK]
PERSIST_STORE                                                   [OK]
BAD_INV_ORDER                                                   [OK]
TRANSIENT                                                       [OK]
FREE_MEM                                                        [OK]
INV_IDENT                                                       [OK]
INV_FLAG                                                        [OK]
INTF_REPOS                                                      [OK]
BAD_CONTEXT                                                     [OK]
OBJ_ADAPTER                                                     [OK]
DATA_CONVERSION                                                 [OK]
OBJECT_NOT_EXIST                                                [OK]
TRANSACTION_REQUIRED                                            [OK]
TRANSACTION_ROLLEDBACK                                          [OK]
INVALID_TRANSACTION                                             [OK]
INV_POLICY                                                      [OK]
CODESET_INCOMPATIBLE                                            [OK]
REBIND                                                          [OK]
TIMEOUT                                                         [OK]
TRANSACTION_UNAVAILABLE                                         [OK]
TRANSACTION_MODE                                                [OK]
BAD_QOS                                                         [OK]




* Internet Inter-ORB Protocol (CORBA 2.6 - Chapter 15)
------------------------------------------------------

·Functional Tests
=================

Test Case CDR
-------------

GIOP 1.0 tests with TIDORB

Struct with basic types: 
        Struct
        Float
        Double
        Long
        Unsigned Long
        Short
        Unsigned Short
        Char
        Wchar
        Boolean
        Octet
        Long Double
        Long Long
        Unsigned Long Long
14 IDL types x 4 operations (in, inout, out, ret) = 56 tests    [OK]

Struct with complex types:
        Unbounded String
        Bounded String
        Unbounded WString
        Bounded WString
        Fixed
        Short Sequence
        Unsigned Short Sequence
        Long Sequence
        Unsigned Long Sequence
        Long Long Sequence
        Unsigned Long Long Sequence
        Float Sequence
        Double Sequence
        Long Double Sequence
        Char sequence
        WChar sequence
        Any sequence
        Array of Long Sequence
        Bidimensional Array of Long Sequence
        Array of Float
        Bidimensional Array of Float
        Array of Char
        Bidimensional Array of Char
        Array of Any
        Bidimensional Array of Any
25 IDL types x 4 operations (in, inout, out, ret) = 100 tests   [OK]



SimpleUnion: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

ComplexUnion: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Enum: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Sequence of Booleans: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Sequence of Structs: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Sequence of Enums: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Array of Short: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Array of String: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Array of Struct: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Any: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

SimpleValueType: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Exception: 
1 IDL type x 1 operation (raise exception) = 1 test             [OK]

ObjectType: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

typedef Object: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Object reference: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

GIOP Fragments Test: 
1 IDL type x 1 operation (in) = 1 test                          [OK]



GIOP 1.1 tests with TIDORB

Struct with basic types: 
        Struct
        Float
        Double
        Long
        Unsigned Long
        Short
        Unsigned Short
        Char
        Wchar
        Boolean
        Octet
        Long Double
        Long Long
        Unsigned Long Long
14 IDL types x 4 operations (in, inout, out, ret) = 56 tests    [OK]

Struct with complex types: 
        Unbounded String
        Bounded String
        Unbounded WString
        Bounded WString
        Fixed
        Short Sequence
        Unsigned Short Sequence
        Long Sequence
        Unsigned Long Sequence
        Long Long Sequence
        Unsigned Long Long Sequence
        Float Sequence
        Double Sequence
        Long Double Sequence
        Char sequence
        WChar sequence
        Any sequence
        Array of Long Sequence
        Bidimensional Array of Long Sequence
        Array of Float
        Bidimensional Array of Float
        Array of Char
        Bidimensional Array of Char
        Array of Any
        Bidimensional Array of Any
25 IDL types x 4 operations (in, inout, out, ret) = 100 tests   [OK]


SimpleUnion: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

ComplexUnion: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Enum: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Sequence of Booleans: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Sequence of Structs: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Sequence of Enums: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Array of Short: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Array of String: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Array of Struct: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Any: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

SimpleValueType: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Exception: 
1 IDL type x 1 operation (raise exception) = 1 test             [OK]

ObjectType: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

typedef Object: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Object reference: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

GIOP Fragments Test: 
1 IDL type x 1 operation (in) = 1 test                          [OK]


GIOP 1.2 tests with TIDORB


Struct with basic types: 
        Struct
        Float
        Double
        Long
        Unsigned Long
        Short
        Unsigned Short
        Char
        Wchar
        Boolean
        Octet
        Long Double
        Long Long
        Unsigned Long Long
14 IDL types x 4 operations (in, inout, out, ret) = 56 tests    [OK]

Struct with complex types: 
        Unbounded String
        Bounded String
        Unbounded WString
        Bounded WString
        Fixed
        Short Sequence
        Unsigned Short Sequence
        Long Sequence
        Unsigned Long Sequence
        Long Long Sequence
        Unsigned Long Long Sequence
        Float Sequence
        Double Sequence
        Long Double Sequence
        Char sequence
        WChar sequence
        Any sequence
        Array of Long Sequence
        Bidimensional Array of Long Sequence
        Array of Float
        Bidimensional Array of Float
        Array of Char
        Bidimensional Array of Char
        Array of Any
        Bidimensional Array of Any
25 IDL types x 4 operations (in, inout, out, ret) = 100 tests   [OK]

SimpleUnion: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

ComplexUnion: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Enum: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Sequence of Booleans: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Sequence of Structs: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Sequence of Enums: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Array of Short: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Array of String: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Array of Struct: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Any: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

SimpleValueType: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Exception: 
1 IDL type x 1 operation (raise exception) = 1 test             [OK]

ObjectType: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]
typedef Object: 

1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]
Object reference: 

1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

GIOP Fragments Test: 
1 IDL type x 1 operation (in) = 1 test                          [OK]


Test Case Interoperability
--------------------------

GIOP 1.0 tests: TAO client + TIDORB server

Struct with basic types: 
        Struct
        Float
        Double
        Long
        Unsigned Long
        Short
        Unsigned Short
        Char
        Wchar
        Boolean
        Octet
        Long Double
        Long Long
        Unsigned Long Long
14 IDL types x 4 operations (in, inout, out, ret) = 56 tests    [OK]


Struct with complex types: 
        Unbounded String
        Bounded String
        Unbounded WString
        Bounded WString
        Fixed
        Short Sequence
        Unsigned Short Sequence
        Long Sequence
        Unsigned Long Sequence
        Long Long Sequence
        Unsigned Long Long Sequence
        Float Sequence
        Double Sequence
        Long Double Sequence
        Char sequence
        WChar sequence
        Any sequence
        Array of Long Sequence
        Bidimensional Array of Long Sequence
        Array of Float
        Bidimensional Array of Float
        Array of Char
        Bidimensional Array of Char
        Array of Any
        Bidimensional Array of Any
25 IDL types x 4 operations (in, inout, out, ret) = 100 tests   [OK] 

SimpleUnion: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

ComplexUnion: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Enum: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Sequence of Booleans: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Sequence of Structs: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Sequence of Enums: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Array of Short: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Array of String: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Array of Struct: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Any: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

SimpleValueType: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Exception: 
1 IDL type x 1 operation (raise exception) = 1 test             [OK]

ObjectType: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

typedef Object: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Object reference: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

GIOP Fragments Test: 
1 IDL type x 1 operation (in) = 1 test                          [OK]


GIOP 1.1 tests: TAO client + TIDORB server

Struct with basic types: 
        Struct
        Float
        Double
        Long
        Unsigned Long
        Short
        Unsigned Short
        Char
        Wchar
        Boolean
        Octet
        Long Double
        Long Long
        Unsigned Long Long
14 IDL types x 4 operations (in, inout, out, ret) = 56 tests    [OK]

Struct with complex types: 
        Unbounded String
        Bounded String
        Unbounded WString
        Bounded WString
        Fixed
        Short Sequence
        Unsigned Short Sequence
        Long Sequence
        Unsigned Long Sequence
        Long Long Sequence
        Unsigned Long Long Sequence
        Float Sequence
        Double Sequence
        Long Double Sequence
        Char sequence
        WChar sequence
        Any sequence
        Array of Long Sequence
        Bidimensional Array of Long Sequence
        Array of Float
        Bidimensional Array of Float
        Array of Char
        Bidimensional Array of Char
        Array of Any
        Bidimensional Array of Any
25 IDL types x 4 operations (in, inout, out, ret) = 100 tests   [OK] 

SimpleUnion: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

ComplexUnion: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Enum: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Sequence of Booleans: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Sequence of Structs: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Sequence of Enums: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Array of Short: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Array of String: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Array of Struct: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Any: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

SimpleValueType: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Exception: 
1 IDL type x 1 operation (raise exception) = 1 test             [OK]

ObjectType: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

typedef Object: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Object reference: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

GIOP Fragments Test: 
1 IDL type x 1 operation (in) = 1 test                          [OK]


GIOP 1.2 tests: TAO client + TIDORB server

Struct with basic types: 
        Struct
        Float
        Double
        Long
        Unsigned Long
        Short
        Unsigned Short
        Char
        Wchar
        Boolean
        Octet
        Long Double
        Long Long
        Unsigned Long Long
14 IDL types x 4 operations (in, inout, out, ret) = 56 tests    [OK]

Struct with complex types: 
        Unbounded String
        Bounded String
        Unbounded WString
        Bounded WString
        Fixed
        Short Sequence
        Unsigned Short Sequence
        Long Sequence
        Unsigned Long Sequence
        Long Long Sequence
        Unsigned Long Long Sequence
        Float Sequence
        Double Sequence
        Long Double Sequence
        Char sequence
        WChar sequence
        Any sequence
        Array of Long Sequence
        Bidimensional Array of Long Sequence
        Array of Float
        Bidimensional Array of Float
        Array of Char
        Bidimensional Array of Char
        Array of Any
        Bidimensional Array of Any
25 IDL types x 4 operations (in, inout, out, ret) = 100 tests   [OK]

SimpleUnion: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

ComplexUnion: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Enum: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Sequence of Booleans: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Sequence of Structs: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Sequence of Enums: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Array of Short: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Array of String: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Array of Struct: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Any: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

SimpleValueType: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Exception: 
1 IDL type x 1 operation (raise exception) = 1 test             [OK]

ObjectType: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

typedef Object: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

Object reference: 
1 IDL type x 4 operations (in, inout, out, ret) = 4 tests       [OK]

GIOP Fragments Test: 
1 IDL type x 1 operation (in) = 1 test                          [OK]


Test Case GIOPMessages
----------------------

[GIOP Messages]: GIOP 1.0 tests with TIDORB

GIOP Request Message: client -> server                          [OK]
GIOP Reply Message: server -> client                            [OK]
GIOP Locate Request/Reply messages (x2)                         [OK]
GIOP Close Message: server-> client                             [OK]

[GIOP Messages]: GIOP 1.1 tests with TIDORB

GIOP Request Message: client -> server                          [OK]
GIOP Reply Message: server -> client                            [OK]
GIOP Locate Request/Reply messages (x2)                         [OK]
GIOP Close Message: server-> client                             [OK]

[GIOP Messages]: GIOP 1.2 tests with TIDORB

GIOP Request Message: client -> server                          [OK]
GIOP Reply Message: server -> client                            [OK]
GIOP Locate Request/Reply messages (x2)                         [OK]
GIOP Close Message: server-> client                             [OK]

[GIOP Messages]: GIOP 1.0 -> TIDORB client + TAO server

GIOP Request Message: client -> server                          [OK]
GIOP Reply Message: server -> client                            [OK]
GIOP Locate Request/Reply messages (x2)                         [OK]
GIOP Close Message: server-> client                             [OK]

[GIOP Messages]: GIOP 1.1 -> TIDORB client + TAO server

GIOP Request Message: client -> server                          [OK]
GIOP Reply Message: server -> client                            [OK]
GIOP Locate Request/Reply messages (x2)                         [OK]
GIOP Close Message: server-> client                             [OK]

[GIOP Messages]: GIOP 1.2 -> TIDORB client + TAO server

GIOP Request Message: client -> server                          [OK]
GIOP Reply Message: server -> clientq                           [OK]
GIOP Locate Request/Reply messages (x2)                         [OK]
GIOP Close Message: server-> client                             [OK]


Test Case Bidirectional
-----------------------

GIOP 1.2 tests with TIDORB

Request message sent from server to client                      [OK]
Reply message sent from client to server                        [OK]

GIOP 1.2 -> TIDORB client + TAO server

Request message sent from server to client                      [OK]
Reply message sent from client to server                        [OK]




* DII - Dynamic Invocation Interface (CORBA 2.6 - Chapter 7)
============================================================

·Functional Tests
=================

Test Case NVListAPI
-------------------
Test create_NVList
ORB::create_list                                                [OK]

Test add
NVList::add (x3)                                                [OK]
NVList::count (x2)                                              [OK]

Test add_item
NVList::add_item (x3)                                           [OK]

Test add_value
NVList::add_value (x3)                                          [OK]

Test add_item_consume
NVList::add_item_consume                                        [OK]

Test add_value_consume
NVList::add_value_consume                                       [OK]

Test item
NVList::item (x2)                                               [OK]

Test remove
NVList::remove (x2)                                             [OK]


Test Case RequestAPI
--------------------
Test target
Request::target()                                               [OK]

Test operation
Request::operation()                                            [OK]

Test ctx
Request::ctx()                                                  [OK]
Request::ctx(Context_ptr)                                       [OK]

Test invoke_with_request
Request::invoke() (x3)                                          [OK]
Request::add_in_arg()                                           [OK]
Request::add_inout_arg()                                        [OK]
Request::add_out_arg()                                          [OK]
Request::set_return_type                                        [OK]
Request::return_value                                           [OK]
Request::arguments (x2)                                         [OK]
Request::result                                                 [OK]
Request::env                                                    [OK]
Reception of in argument in server side                         [OK]

Test invoke_with_create_request_v2
Request::invoke() (x3)                                          [OK]
Request::set_return_type                                        [OK]
Reception of in argument in server side                         [OK]
Request::exceptions                                             [OK]
Request::contexts                                               [OK]
ORB::create_exception_list                                      [OK]
ORB::create_context_list                                        [OK]

Test send_oneway
Request::send_oneway() (x3)                                     [OK]
Request::set_return_type                                        [OK]
Reception of in argument in server side                         [OK]

Test send_deferred
Request::send_deferred() (x3)                                   [ERROR]
Request::get_response                                           [ERROR]
Request::poll_response                                          [ERROR]
unexpected exception caught - Caught: unknown.                  [ERROR]


* DSI - Dynamic Skeleton Interface (CORBA 2.6 - Chapter 8)
----------------------------------------------------------

·Functional Tests
=================

Test Case ServerRequestAPI
--------------------------
Test operation
	 
ServerRequest::operation                                        [OK]
ServerRequest::set_result                                       [OK] 
ServerRequest::arguments (x6)                                   [OK]
ServerRequest::ctx                                              [ERROR]
ServerRequest::set_SystemException (x2)                         [OK]                       
ServerRequest::set_UserException (x2)                           [OK]
ServerRequest::ctx_ExceptionalCase1                             [OK]
ServerRequest::ctx_ExceptionalCase2                             [OK] 
ServerRequest::except_ExceptionalCase1                          [OK] 
ServerRequest::general_ExceptionalCase1                         [OK]
ServerRequest::general_ExceptionalCase2                         [OK]
ServerRequest::general_ExceptionalCase3                         [ERROR]



* Portable Object Adapter (CORBA 2.6 - Chapter 11)
--------------------------------------------------

·Structural Tests
=================

Test Case POA
-------------
Test Interfaces
	 
POA Manager Interface (11.3.2 )

void activate()                                                 [OK] 
void hold_requests(CORBA::Boolean wait_for_completion)          [OK] 
void discard_requests(CORBA::Boolean wait_for_completion)       [OK] 
void deactivate(CORBA::Boolean, CORBA::Boolean)                 [OK] 
PortableServer::POAManager::State get_state()                   [OK] 

AdapterActivator Interface (11.3.3) 
CORBA::Boolean unknown_adapter(parent, name)                    [OK] 

ServantActivator Interface (11.3.5) 
PortableServer::Servant incarnate(oid, adapter)                 [OK] 
void etherealize(oid, adapter, serv, cleanup, remaining)        [OK] 

ServantLocator Interface (11.3.6 )
preinvoke(oid, adapter, operation, the_cookie)                  [OK] 
void postinvoke(oid, adapter, operation, cookie, servant)       [OK] 

POA Interface (11.3.8 )

create_POA(adapter_name, a_POAManager, policies)                [OK] 
find_POA(adapter_name, activate_it)                             [OK] 
void destroy(etherealize_objects, wait_for_completion)          [OK] 
create_thread_policy(PortableServer::ThreadPolicyValue value)   [OK] 
create_lifespan_policy(value)                                   [OK] 
create_id_uniqueness_policy(value)                              [OK] 
create_id_assignment_policy(value)                              [OK] 
create_implicit_activation_policy(value)                        [OK] 
create_servant_retention_policy(value)                          [OK] 
create_request_processing_policy(value)                         [OK] 
char* the_name()                                                [OK] 
PortableServer::POA_ptr the_parent()                            [OK] 
PortableServer::POAList* the_children()                         [OK] 
PortableServer::POAManager_ptr the_POAManager()                 [OK] 
PortableServer::AdapterActivator_ptr the_activator()            [OK] 
void the_activator(PortableServer::AdapterActivator_ptr value)  [OK]
PortableServer::ServantManager_ptr get_servant_manager()        [OK] 
void set_servant_manager(imgr)                                  [OK] 
PortableServer::Servant get_servant()                           [OK] 
void set_servant(PortableServer::Servant p_servant)             [OK] 
PortableServer::ObjectId* activate_object(p_servant)            [OK] 
void activate_object_with_id(id, p_servant)                     [OK] 
void deactivate_object(const PortableServer::ObjectId& oid)     [OK] 
create_reference(const char* intf)                              [OK] 
create_reference_with_id(oid, intf)                             [OK] 
servant_to_id(PortableServer::Servant p_servant)                [OK] 
servant_to_reference(PortableServer::Servant p_servant)         [OK] 
reference_to_servant(CORBA::Object_ptr reference)               [OK] 
reference_to_id(CORBA::Object_ptr reference)                    [OK] 
id_to_servant(const PortableServer::ObjectId& oid)              [OK] 
id_to_reference(const PortableServer::ObjectId& oid)            [OK] 
CORBA::OctetSeq* id()                                           [OK] 

POA Policy Objects (11.3.7 ) 
ThreadPolicy interface
PortableServer::ThreadPolicyValue value()                       [OK] 
LifespanPolicy interface
PortableServer::LifespanPolicyValue value()                     [OK] 
IdUniquenessPolicy interface
PortableServer::IdUniquenessPolicyValue value()                 [OK] 
IdAssignmentPolicy interface
PortableServer::IdAssignmentPolicyValue value()                 [OK] 
ImplicitActivationPolicy interface
PortableServer::ImplicitActivationPolicyValue value()           [OK] 
ServantRetentionPolicy interface
PortableServer::ServantRetentionPolicyValue value()             [OK] 
RequestProcessingPolicy interface 
PortableServer::RequestProcessingPolicyValue value()            [OK] 

Current interface (11.3.9 )
PortableServer::POA_ptr get_POA()                               [OK] 
PortableServer::ObjectId* get_object_id()                       [OK] 
CORBA::Object_ptr get_reference()                               [OK] 
PortableServer::Servant get_servant()                           [OK]



·Functional Tests
=================

Test Case AbstractModel
-----------------------
Test check_default_policies
Setup Section: ORB_init + RootPOA + the_POAManager              [OK]
PortableServer::POA::_narrow(RootPOA)                           [OK]
manager= root_poa->the_POAManager()                             [OK]
test_ref =servant->_this()                                      [OK]
oid = root_poa->servant_to_id(servant)                          [OK]
POA manager activate                                            [OK]
Testing Corba Object: SUM 3+4=7                                 [OK]
POA deactivate_object                                           [OK]
Testing Corba Object after destroy, Exc=OBJECT_NOT_EXIST 	[OK]
Deactivate POA manager                                          [OK]
Activate POA manager after deactivating, Exc=AdapterInactive 	[OK]
Rebuilding all to check root manager re-activate                [OK]
orb->shutdown(true)                                             [OK]
	 
Setup Section: ORB_init + RootPOA + the_POAManager              [OK]
Activate POA manager after rebuilding                           [OK]
orb->shutdown(true)                                             [OK]

Test check_policies_combination
Setup Section: ORB_init + RootPOA + the_POAManager              [OK]
root_poa->create_id_assignment_policy USER_ID                   [OK]
root_poa->create_lifespan_policy PERSISTENT                     [OK]
root_poa->create_implicit_activation_policy NO_IMPL_ACT 	[OK]
root_poa->create_servant_retention_policy RETAIN                [OK]
root_poa->create_id_uniqueness_policy MULTIPLE_ID               [OK]
root_poa->create_request_processing_policy USE_AOM_ONLY 	[OK]
root_poa->create_POA( Child_POA, NULL, policies)                [OK]
Destroy policies                                                [OK]
poa_hijo->the_POAManager()                                      [OK]
oid=PortableServer::string_to_ObjectId                          [OK]
poa_hijo->activate_object_with_id                               [OK]
ref_for_ior=poa_hijo->create_reference_with_id                  [OK]
POA manager activate                                            [OK]
Testing Corba Object: SUM 3+4=7                                 [OK]
POA deactivate_object                                           [OK]
Testing Corba Object after destroy, Exc=OBJECT_NOT_EXIST 	[OK]
Deactivate POA manager                                          [OK]
Activate POA manager after deactivating, Exc=AdapterInactive 	[OK]
child_poa->destroy                                              [OK]
Rebuilding all to check root manager re-activate                [OK]
orb->shutdown(true)                                             [OK]
	 
Setup Section: ORB_init + RootPOA + the_POAManager              [OK]
Activate POA manager after rebuilding                           [OK]
orb->shutdown(true)                                             [OK]

Test check_invalid_policies
Setup Section: ORB_init + RootPOA + the_POAManager              [OK]
manager=poa_hijo->the_POAManager()                              [OK]
poa_hijo->activate_object 
  (11.3.8.14) requires SYSTEM_ID + RETAIN, WrongPolicy          [OK]
orb->shutdown(true)                                             [OK]

Test check_single_thread_policy
Setup Section: ORB_init + RootPOA + the_POAManager              [OK]
root_poa->create_thread_policy SINGLE_THREAD_MODEL              [OK]
root_poa->create_POA( Child_POA, NULL, policies)                [OK]
oid=poa_hijo->activate_object (Single Thread)                   [OK]
ref_for_ior=poa_hijo->id_to_reference (Single Thread)           [OK]
MyCalculator::op=3015417568 calling reentrant operation 
MyCalculator::op=3015417568                                     [OK]
Single Thread Policy (11.3.7.1: allow reentrant calls)          [OK]
poa_hijo->deactivate_object(oid2) (Single Thread)               [OK]
poa_hijo->deactivate_object(oid) (Single Thread)                [OK]
child_poa->destroy                                              [OK]
orb->shutdown(true)                                             [OK]             

Test check_persistent_policy
Setup Section: ORB_init + RootPOA + the_POAManager              [OK]
oid=PortableServer::string_to_ObjectId (PERSISTENT)             [OK]
poa_hijo->activate_object_with_id(oid,servant) (PERSISTENT) 	[OK]
poa_hijo->create_reference_with_id (PERSISTENT)                 [OK]
Example::Calculator::_narrow(ref_for_ior)                       [OK]
manager->activate();                                            [OK]
Testing Corba Obj Operation (PERSISTENT)                        [OK]
poa_hijo->destroy (PERSISTENT)                                  [OK]
poa_hijo->activate_object_with_id (PERSISTENT), repetition=1 	[OK]
poa_hijo->create_reference_with_id (PERSISTENT), repetition=1 	[OK]
orb->shutdown(true)                                             [OK]


Test Case POAInterfaces
-----------------------
Test default_servant
Setup Section: ORB_init + RootPOA + the_POAManager              [OK]
thermometers_poa = root_poa->create_POA                         [OK]
thermometers_poa_mgr = thermometers_poa->the_POAManager  	[OK]
cur = PortableServer::Current::_narrow                          [OK]
Create a Default Servant (for Child POA)                        [OK]
thermometers_poa->set_servant(termometer)                       [OK]
controller_poa = root_poa->create_POA (Controller_POA)  	[OK]
controller_poa->activate_object_with_id(oid, controller)  	[OK]
Test::Controller_var ctrl_ref = Test::Controller::_narrow(obj) 	[OK]
root_poa_mgr->activate() + thermometers_poa_mgr->activate()  	[OK]
Controller_default_impl::get_thermometer(0)                     [OK]
Test::Thermometer::_narrow(m_obj)                               [OK]
PortableServer::Current_ptr current->get_object_id()            [OK]
Testing Object param: thermometer_ref->temperature()=10 	[OK]
Testing Object param: thermometer_ref->temperature()=19 	[OK]
thermometers_poa->destroy+controller_poa->destroy               [OK]
orb->shutdown(true)                                             [OK]
orb->destroy()                                                  [OK]

Test servant_activator
Setup Section: ORB_init + RootPOA + the_POAManager              [OK]
thermometers_poa = root_poa->create_POA                         [OK]
thermometers_poa_mgr = thermometers_poa->the_POAManager  	[OK]
Create a Servant Activator (for Child POA)                      [OK]
thermometers_poa->set_servant_manager                           [OK]
controller_poa = root_poa->create_POA (Controller_POA)  	[OK]
controller_poa->activate_object_with_id(oid, controller)  	[OK]
Test::Controller_var ctrl_ref = Test::Controller::_narrow(obj) 	[OK]
root_poa_mgr->activate() + thermometers_poa_mgr->activate()  	[OK]
Controller_default_impl::get_thermometer(0):                    [OK] 
Test::Thermometer::_narrow(m_obj)                               [OK]
ThermometerActivator_impl::incarnate()                          [OK]
servant = new Thermometer_activator_impl(element)               [OK]
Testing Object param: thermometer_ref->temperature()=19 	[OK]
thermometers_poa->destroy                                       [OK]
+controller_poa->destroy                                        [OK]

Test servant_locator
Setup Section: ORB_init + RootPOA + the_POAManager              [OK]
thermometers_poa = root_poa->create_POA                         [OK]
thermometers_poa_mgr = thermometers_poa->the_POAManager  	[OK]
Create a Servant Locator for Child POA                          [OK]
thermometers_poa->set_servant_manager(locator)                  [OK]
controller_poa = root_poa->create_POA (Controller_POA)          [OK]
controller_poa->activate_object_with_id(oid, controller)  	[OK]
Test::Controller_var ctrl_ref = Test::Controller::_narrow(obj) 	[OK]
root_poa_mgr->activate() + thermometers_poa_mgr->activate()  	[OK]
[POA Tests] Controller_default_impl::get_thermometer(0):        [OK]
Test::Thermometer::_narrow(m_obj)                               [OK]
[POA Tests] ThermometerLocator_impl::preinvoke()                [OK]
[POA Tests] servant = new Thermometer_locator_impl(element) 	[OK]
[POA Tests] ThermometerLocator_impl::postinvoke()               [OK]
Testing Object param: thermometer_ref->temperature()=19 	[OK]
thermometers_poa->destroy+controller_poa->destroy               [OK]
[POA Tests] ThermometerActivator_impl::etherealize()            [OK]
orb->shutdown(true)                                             [OK]
orb->destroy()                                                  [OK]



* Dynamic ANY (CORBA 2.6 - Chapter 9)
-------------------------------------

·Structural Tests
=================

Test Case test
--------------
Test DynAny::DynAnyFactoryAPI
	 
create_dyn_any(const CORBA::Any& value)                         [OK]
create_dyn_any_from_type_code(CORBA::TypeCode_ptr type) 	[OK]

Test DynAny::DynAnyAPI

TypeCode_ptr type()                                             [OK]
void assign(DynamicAny::DynAny_ptr dyn_any)                     [OK]
void from_any(const Any& value)                                 [OK]
Any* to_any()                                                   [OK]
Boolean equal(DynamicAny::DynAny_ptr dyn_any)                   [OK]
void destroy()                                                  [OK]
DynamicAny::DynAny_ptr copy()                                   [OK]
void insert_boolean(Boolean value)                              [OK]
void insert_octet(Octet value)                                  [OK]
void insert_char(Char value)                                    [OK]
void insert_short(Short value)                                  [OK]
void insert_ushort(UShort value)                                [OK]
void insert_long(Long value)                                    [OK]
void insert_ulong(ULong value)                                  [OK]
void insert_float(Float value)                                  [OK]
void insert_double(Double value)                                [OK]
void insert_string(const char* value)                           [OK]
void insert_reference(Object_ptr value)                         [OK]
void insert_typecode(TypeCode_ptr value)                        [OK]
void insert_longlong(LongLong value)                            [OK]
void insert_ulonglong(ULongLong value)                          [OK]
void insert_longdouble(LongDouble value)                        [OK]
void insert_wchar(WChar value)                                  [OK]
void insert_wstring(const WChar* value)                         [OK]
void insert_any(const Any& value)                               [OK]
void insert_dyn_any(DynamicAny::DynAny_ptr value)               [OK]
void insert_val(ValueBase_ptr value)                            [OK]
Boolean get_boolean()                                           [OK]
Octet get_octet()                                               [OK]
Char get_char()                                                 [OK]
Short get_short()                                               [OK]
UShort get_ushort()                                             [OK]
Long get_long()                                                 [OK]
ULong get_ulong()                                               [OK]
Float get_float()                                               [OK]
Double get_double()                                             [OK]
char* get_string()                                              [OK]
Object_ptr get_reference()                                      [OK]
TypeCode_ptr get_typecode()                                     [OK]
LongLong get_longlong()                                         [OK]
ULongLong get_ulonglong()                                       [OK]
LongDouble get_longdouble()                                     [OK]
WChar get_wchar()                                               [OK]
WChar* get_wstring()                                            [OK]
Any* get_any()                                                  [OK]
DynamicAny::DynAny_ptr get_dyn_any()                            [OK]
ValueBase_ptr get_val()                                         [OK]
Boolean seek(Long index)                                        [OK]
void rewind()                                                   [OK]
Boolean next()                                                  [OK]
ULong component_count()                                         [OK]
DynamicAny::DynAny_ptr current_component()                      [OK]
void insert_abstract(AbstractBase_ptr value)                    [OK]
AbstractBase_ptr get_abstract()                                 [OK]
void insert_boolean_seq(const ::BooleanSeq& value)              [OK]
void insert_octet_seq(const ::OctetSeq& value)                  [OK]
void insert_char_seq(const ::CharSeq& value)                    [OK]
void insert_short_seq(const ::ShortSeq& value)                  [OK]
void insert_ushort_seq(const ::UShortSeq& value)                [OK]
void insert_long_seq(const ::LongSeq& value)                    [OK]
void insert_ulong_seq(const ::ULongSeq& value)                  [OK]
void insert_float_seq(const ::FloatSeq& value)                  [OK]
void insert_double_seq(const ::DoubleSeq& value)                [OK]
void insert_longlong_seq(const ::LongLongSeq& value)            [OK]
void insert_ulonglong_seq(const ::ULongLongSeq& value)          [OK]
void insert_longdouble_seq(const ::LongDoubleSeq& value)        [OK]
void insert_wchar_seq(const ::WCharSeq& value)                  [OK]
BooleanSeq* get_boolean_seq()                                   [OK]
OctetSeq* get_octet_seq()                                       [OK]
CharSeq* get_char_seq()                                         [OK]
ShortSeq* get_short_seq()                                       [OK]
UShortSeq* get_ushort_seq()                                     [OK]
LongSeq* get_long_seq()                                         [OK]
ULongSeq* get_ulong_seq()                                       [OK]
FloatSeq* get_float_seq()                                       [OK]
DoubleSeq* get_double_seq()                                     [OK]
LongLongSeq* get_longlong_seq()                                 [OK]
ULongLongSeq* get_ulonglong_seq()                               [OK]
LongDoubleSeq get_longdouble_seq()                              [OK]
WCharSeq* get_wchar_seq()                                       [OK]


Test DynAny::DerivedDynAnyAPIs


DynStruct
	char* current_member_name()                             [OK]
	TCKind current_member_kind()                            [OK]       
	DynamicAny::NameValuePairSeq* get_members()             [OK]
	void set_members(value)                                 [OK]
	DynamicAny::NameDynAnyPairSeq* get_members_as_dyn_any() [OK]
	void set_members_as_dyn_any(value)                      [OK]

DynUnion 
	DynamicAny::DynAny_ptr get_discriminator()              [OK]
	void set_discriminator(DynamicAny::DynAny_ptr d)        [OK]
	void set_to_default_member()                            [OK]
	void set_to_no_active_member()                          [OK]
	CORBA::Boolean has_no_active_member()                   [OK]
	::CORBA::TCKind discriminator_kind()                    [OK]
	DynamicAny::DynAny_ptr member()                         [OK]
	char* member_name()                                     [OK]
	::CORBA::TCKind member_kind()                           [OK]
	CORBA::Boolean has_no_active_member()                   [OK]

DynSequence 
	CORBA::ULong get_length()                               [OK]
	void set_length(CORBA::ULong len)                       [OK]
	DynamicAny::AnySeq* get_elements()                      [OK]
	void set_elements(const DynamicAny::AnySeq& value)      [OK]
	DynamicAny::DynAnySeq* get_elements_as_dyn_any()        [OK]
	void set_elements_as_dyn_any(value)                     [OK]

DynArray 
	DynamicAny::AnySeq* get_elements()                      [OK]
	void set_elements(const DynamicAny::AnySeq& value)      [OK]
	DynamicAny::DynAnySeq* get_elements_as_dyn_any()        [OK]
	void set_elements_as_dyn_any(value)                     [OK]

DynValueCommon 
	CORBA::Boolean is_null()                                [OK]
	void set_to_null()                                      [OK]
	void set_to_value()                                     [OK]

DynValue 
	char* current_member_name()                             [OK]
	::CORBA::TCKind current_member_kind()                   [OK]
	DynamicAny::NameValuePairSeq* get_members()             [OK]
	void set_members(value)                                 [OK]
	DynamicAny::NameDynAnyPairSeq* get_members_as_dyn_any() [OK]
	void set_members_as_dyn_any(value)                      [OK]

DynValueBox 
	CORBA::Any* get_boxed_value()                           [OK]
	void set_boxed_value(const CORBA::Any& boxed)           [OK]
	DynamicAny::DynAny_ptr get_boxed_value_as_dyn_any()     [OK]
	void set_boxed_value_as_dyn_any(boxed)                  [OK]



·Functional Tests
=================

Test Case DynAnyFactoryAPI
--------------------------
Test create_dyn_any
DynAnyFactoryAPI::create_dyn_any (x 100)                        [OK]

Test create_dyn_any_from_type_code
DynAnyFactoryAPI::create_dyn_any_from_type_code (x 154)         [OK]
DynAnyFactoryAPI::create_dyn_any_from_type_code (x 8)           [ERROR]


Test Case DynAnyAPI
-------------------

Test type
DynAnyAPI::type (x 20)                                          [OK]	 

Test assign
DynAnyAPI::assign (x 56)                                        [OK]
DynAnyAPI::assign (x 1)                                         [ERROR]

Test from_any
DynAnyAPI::from_any (x 3)                                       [OK]

Test to_any
DynAnyAPI::to_any (x 2)                                         [OK]	 

Test equal
DynAnyAPI::equal (x 2)                                          [OK]	 

Test destroy
DynAnyAPI::destroy (x 5)                                        [OK]	 

Test copy
DynAnyAPI::copy (x 1)                                           [OK]

Test insertAndGetBasicType
DynAnyAPI::insertAndGetBasicType (x 12)                         [OK]

Test insertAndGetSequenceOfBasicTypes
DynAnyAPI::insertAndGetSequenceOfBasicTypes (x 0)               [OK]

Test insertAndGetConstructedDynAny
DynAnyAPI::insertAndGetConstructedDynAny (x 0)                  [OK]	 

Test seek
DynAnyAPI::seek (x 6)                                           [OK]	 

Test rewind
DynAnyAPI::rewind (x 3)                                         [OK]	 

Test next
DynAnyAPI::next (x 6)                                           [OK]

Test component_count
DynAnyAPI::component_count (x 2)                                [OK]

Test current_component
DynAnyAPI::current_component (x 9)                              [OK]
	 

* Derived DynAny APIs

Test Case DynArrayAPI
---------------------
Test get_set_elements
DynArrayAPI::get_set_elements (x 5)                             [OK]

Test get_set_elements_as_dyn_any
DynArrayAPI::get_set_elements_as_dyn_any (x 2)                  [OK]


Test Case DynEnumAPI
--------------------
Test get_set_as_string
DynEnumAPI::get_set_as_string (x 5)                             [OK]
	 
Test get_set_as_ulong
DynEnumAPI::get_set_as_ulong (x 5)                              [OK]


Test Case DynFixedAPI
---------------------
Test get_set_value
DynFixedAPI::get_set_value (x 1)                                [OK]


Test Case DynSequenceAPI
------------------------
Test get_set_length
DynSequenceAPI::get_set_length (x 9)                            [OK]
	 
Test get_set_elements
DynSequenceAPI::get_set_elements (x 4)                          [OK]

Test get_set_elements_as_dyn_any
DynSequenceAPI::get_set_elements_as_dyn_any (x 2)               [OK]


Test Case DynStructAPI
----------------------
Test current_member_name
DynStructAPI::current_member_name (x 4)                         [OK]

Test current_member_kind
DynStructAPI::current_member_kind (x 4)                         [OK]

Test get_set_members
DynStructAPI::get_set_members (x 12)                            [OK]

Test get_set_members_as_dyn_any
DynStructAPI::get_set_members_as_dyn_any (x 12)                 [OK]


Test Case DynUnionAPI
---------------------
Test get_set_discriminator
DynUnionAPI::get_set_discriminator (x 8)                        [OK]
DynUnionAPI::get_set_discriminator (x 1)                        [ERROR]

Test set_is_set_to_default_member
DynUnionAPI::set_is_set_to_default_member (x 2)                 [OK]
DynUnionAPI::set_is_set_to_default_member (x 1)                 [ERROR]

Test set_to_no_active_member
DynUnionAPI::set_to_no_active_member (x 3)                      [OK]
	 
Test has_no_active_member
DynUnionAPI::has_no_active_member (x 1)                         [OK]
DynUnionAPI::has_no_active_member (x 1)                         [UNEXPECTED EXCEPTION]

Test discriminator_kind
DynUnionAPI::discriminator_kind (x 1)                           [OK]	 

Test member
DynUnionAPI::member (x 1)                                       [OK]	 

Test member_name
DynUnionAPI::member_name (x 3)                                  [OK]	 

Test member_kind
DynUnionAPI::member_kind (x 2)                                  [OK]


* Portable Interceptor CODECS (CORBA 2.6 - Chapter 13)

·Functional Tests
=================

Test Case Codecs
----------------

CodecFactory 
IOP::Encoding_v1.0                                              [OK]
IOP::Encoding_v1.1                                              [OK]
IOP::Encoding_v1.2                                              [OK]
IOP::Encoding_v1.3 UnknownEncoding Exception                    [OK]

Test BasicTypes

FloatType codec 1.0
	encode()="3.14159" (x3: ok, bad_param, except)          [OK]
	decode()="3.14159" (x3: ok, bad_param, except)          [OK]
	encode_value()="3.14159" (x3: ok, bad_param, except)    [OK]
	decode_value()="3.14159" (x3: ok, bad_param, except)    [OK]

FloatType codec 1.1
	encode()="3.14159" (x3: ok, bad_param, except)          [OK]
	decode()="3.14159" (x3: ok, bad_param, except)          [OK]
	encode_value()="3.14159" (x3: ok, bad_param, except)    [OK]
	decode_value()="3.14159" (x3: ok, bad_param, except)    [OK]

FloatType codec 1.2
	encode()="3.14159" (x3: ok, bad_param, except)          [OK]
	decode()="3.14159" (x3: ok, bad_param, except)          [OK]
	encode_value()="3.14159" (x3: ok, bad_param, except)    [OK]
	decode_value()="3.14159" (x3: ok, bad_param, except)    [OK]

DoubleType codec 1.0
	encode()="3e+08" (x3: ok, bad_param, except)            [OK]
	decode()="3e+08" (x3: ok, bad_param, except)            [OK]
	encode_value()="3e+08" (x3: ok, bad_param, except)      [OK]
	decode_value()="3e+08" (x3: ok, bad_param, except)      [OK]

DoubleType codec 1.1
	encode()="3e+08" (x3: ok, bad_param, except)            [OK]
	decode()="3e+08" (x3: ok, bad_param, except)            [OK]
	encode_value()="3e+08" (x3: ok, bad_param, except)      [OK]
	decode_value()="3e+08" (x3: ok, bad_param, except)      [OK]

DoubleType codec 1.2
	encode()="3e+08" (x3: ok, bad_param, except)            [OK]
	decode()="3e+08" (x3: ok, bad_param, except)            [OK]
	encode_value()="3e+08" (x3: ok, bad_param, except)      [OK]
	decode_value()="3e+08" (x3: ok, bad_param, except)      [OK]

LongDoubleType codec 1.0
	encode()="3e+08" (x3: ok, bad_param, except)            [OK]
	decode()="3e+08" (x3: ok, bad_param, except)            [OK]
	encode_value()="3e+08" (x3: ok, bad_param, except)      [OK]
	decode_value()="3e+08" (x3: ok, bad_param, except)      [OK]

LongDoubleType codec 1.1
	encode()="3e+08" (x3: ok, bad_param, except)            [OK]
	decode()="3e+08" (x3: ok, bad_param, except)            [OK]
	encode_value()="3e+08" (x3: ok, bad_param, except)      [OK]
	decode_value()="3e+08" (x3: ok, bad_param, except)      [OK]

LongDoubleType codec 1.2
	encode()="3e+08" (x3: ok, bad_param, except)            [OK]
	decode()="3e+08" (x3: ok, bad_param, except)            [OK]
	encode_value()="3e+08" (x3: ok, bad_param, except)      [OK]
	decode_value()="3e+08" (x3: ok, bad_param, except)      [OK]

ShortType codec 1.0
	encode()="128" (x3: ok, bad_param, except)              [OK]
	decode()="128" (x3: ok, bad_param, except)              [OK]
	encode_value()="128" (x3: ok, bad_param, except)        [OK]
	decode_value()="128" (x3: ok, bad_param, except)        [OK]

ShortType codec 1.1
	encode()="128" (x3: ok, bad_param, except)              [OK]
	decode()="128" (x3: ok, bad_param, except)              [OK]
	encode_value()="128" (x3: ok, bad_param, except)        [OK]
	decode_value()="128" (x3: ok, bad_param, except)        [OK]

ShortType codec 1.2
	encode()="128" (x3: ok, bad_param, except)              [OK]
	decode()="128" (x3: ok, bad_param, except)              [OK]
	encode_value()="128" (x3: ok, bad_param, except)        [OK]
	decode_value()="128" (x3: ok, bad_param, except)        [OK]

LongType codec 1.0
	encode()="3141592" (x3: ok, bad_param, except)          [OK]
	decode()="3141592" (x3: ok, bad_param, except)          [OK]
	encode_value()="3141592" (x3: ok, bad_param, except)    [OK]
	decode_value()="3141592" (x3: ok, bad_param, except)    [OK]

LongType codec 1.1
	encode()="3141592" (x3: ok, bad_param, except)          [OK]
	decode()="3141592" (x3: ok, bad_param, except)          [OK]
	encode_value()="3141592" (x3: ok, bad_param, except)    [OK]
	decode_value()="3141592" (x3: ok, bad_param, except)    [OK]

LongType codec 1.2
	encode()="3141592" (x3: ok, bad_param, except)          [OK]
	decode()="3141592" (x3: ok, bad_param, except)          [OK]
	encode_value()="3141592" (x3: ok, bad_param, except)    [OK]
	decode_value()="3141592" (x3: ok, bad_param, except)    [OK]

LongLongType codec 1.0
	encode()="3141592" (x3: ok, bad_param, except)          [OK]
	decode()="3141592" (x3: ok, bad_param, except)          [OK]
	encode_value()="3141592" (x3: ok, bad_param, except)    [OK]
	decode_value()="3141592" (x3: ok, bad_param, except)    [OK]

LongLongType codec 1.1
	encode()="3141592" (x3: ok, bad_param, except)          [OK]
	decode()="3141592" (x3: ok, bad_param, except)          [OK]
	encode_value()="3141592" (x3: ok, bad_param, except)    [OK]
	decode_value()="3141592" (x3: ok, bad_param, except)    [OK]

LongLongType codec 1.2
	encode()="3141592" (x3: ok, bad_param, except)          [OK]
	decode()="3141592" (x3: ok, bad_param, except)          [OK]
	encode_value()="3141592" (x3: ok, bad_param, except)    [OK]
	decode_value()="3141592" (x3: ok, bad_param, except)    [OK]

UnsignedShortType codec 1.0
	encode()="128" (x3: ok, bad_param, except)              [OK]
	decode()="128" (x3: ok, bad_param, except)              [OK]
	encode_value()="128" (x3: ok, bad_param, except)        [OK]
	decode_value()="128" (x3: ok, bad_param, except)        [OK]

UnsignedShortType codec 1.1
	encode()="128" (x3: ok, bad_param, except)              [OK]
	decode()="128" (x3: ok, bad_param, except)              [OK]
	encode_value()="128" (x3: ok, bad_param, except)        [OK]
	decode_value()="128" (x3: ok, bad_param, except)        [OK]

UnsignedShortType codec 1.2
	encode()="128" (x3: ok, bad_param, except)              [OK]
	decode()="128" (x3: ok, bad_param, except)              [OK]
	encode_value()="128" (x3: ok, bad_param, except)        [OK]
	decode_value()="128" (x3: ok, bad_param, except)        [OK]

UnsignedLongType codec 1.0
	encode()="3141592" (x3: ok, bad_param, except)          [OK]
	decode()="3141592" (x3: ok, bad_param, except)          [OK]
	encode_value()="3141592" (x3: ok, bad_param, except)    [OK]
	decode_value()="3141592" (x3: ok, bad_param, except)    [OK]

UnsignedLongType codec 1.1
	encode()="3141592" (x3: ok, bad_param, except)          [OK]
	decode()="3141592" (x3: ok, bad_param, except)          [OK]
	encode_value()="3141592" (x3: ok, bad_param, except)    [OK]
	decode_value()="3141592" (x3: ok, bad_param, except)    [OK]

UnsignedLongType codec 1.2
	encode()="3141592" (x3: ok, bad_param, except)          [OK]
	decode()="3141592" (x3: ok, bad_param, except)          [OK]
	encode_value()="3141592" (x3: ok, bad_param, except)    [OK]
	decode_value()="3141592" (x3: ok, bad_param, except)    [OK]

UnsignedLongLongType codec 1.0
	encode()="3141592" (x3: ok, bad_param, except)          [OK]
	decode()="3141592" (x3: ok, bad_param, except)          [OK]
	encode_value()="3141592" (x3: ok, bad_param, except)    [OK]
	decode_value()="3141592" (x3: ok, bad_param, except)    [OK]

UnsignedLongLongType codec 1.1
	encode()="3141592" (x3: ok, bad_param, except)          [OK]
	decode()="3141592" (x3: ok, bad_param, except)          [OK]
	encode_value()="3141592" (x3: ok, bad_param, except)    [OK]
	decode_value()="3141592" (x3: ok, bad_param, except)    [OK]

UnsignedLongLongType codec 1.2
	encode()="3141592" (x3: ok, bad_param, except)          [OK]
	decode()="3141592" (x3: ok, bad_param, except)          [OK]
	encode_value()="3141592" (x3: ok, bad_param, except)    [OK]
	decode_value()="3141592" (x3: ok, bad_param, except)    [OK]

BooleanType codec 1.0
	encode()="1" (x3: ok, bad_param, except)                [OK]
	decode()="1" (x3: ok, bad_param, except)                [OK]
	encode_value()="1" (x3: ok, bad_param, except)          [OK]
	decode_value()="1" (x3: ok, bad_param, except)          [OK]

BooleanType codec 1.1
	encode()="1" (x3: ok, bad_param, except)                [OK]
	decode()="1" (x3: ok, bad_param, except)                [OK]
	encode_value()="1" (x3: ok, bad_param, except)          [OK]
	decode_value()="1" (x3: ok, bad_param, except)          [OK]

BooleanType codec 1.2
	encode()="1" (x3: ok, bad_param, except)                [OK]
	decode()="1" (x3: ok, bad_param, except)                [OK]
	encode_value()="1" (x3: ok, bad_param, except)          [OK]
	decode_value()="1" (x3: ok, bad_param, except)          [OK]

OctetType codec 1.0
	encode()="Â" (x3: ok, bad_param, except)            [OK]
	decode()="Â" (x3: ok, bad_param, except)            [OK]
	encode_value()="Â" (x3: ok, bad_param, except)      [OK]
	decode_value()="Â" (x3: ok, bad_param, except)      [OK]

OctetType codec 1.1
	encode()="Â" (x3: ok, bad_param, except)            [OK]
	decode()="Â" (x3: ok, bad_param, except)            [OK]
	encode_value()="Â" (x3: ok, bad_param, except)      [OK]
	decode_value()="Â" (x3: ok, bad_param, except)      [OK]

OctetType codec 1.2
	encode()="Â" (x3: ok, bad_param, except)            [OK]
	decode()="Â" (x3: ok, bad_param, except)            [OK]
	encode_value()="Â" (x3: ok, bad_param, except)      [OK]
	decode_value()="Â" (x3: ok, bad_param, except)      [OK]

CharType codec 1.0
	encode()="CharType" (x3: ok, bad_param, except)         [OK]
	decode()="CharType" (x3: ok, bad_param, except)         [OK]
	encode_value()="CharType" (x3: ok, bad_param, except)   [OK]
	decode_value()="CharType" (x3: ok, bad_param, except)   [OK]

CharType codec 1.1
	encode()="CharType" (x3: ok, bad_param, except)         [OK]
	decode()="CharType" (x3: ok, bad_param, except)         [OK]
	encode_value()="CharType" (x3: ok, bad_param, except)   [OK]
	decode_value()="CharType" (x3: ok, bad_param, except)   [OK]
CharType codec 1.2
	encode()="CharType" (x3: ok, bad_param, except)         [OK]
	decode()="CharType" (x3: ok, bad_param, except)         [OK]
	encode_value()="CharType" (x3: ok, bad_param, except)   [OK]
	decode_value()="CharType" (x3: ok, bad_param, except)   [OK]

WcharType codec 1.0
	encode_value() (x3: ok, bad_param, excep)               [ERROR]
	decode_value() (x3: ok, bad_param, excep)               [ERROR]
	encode_value() (x3: ok, bad_param, excep)               [ERROR]
	decode_value() (x3: ok, bad_param, excep)               [ERROR]

WcharType codec 1.1
	encode_value() (x3: ok, bad_param, excep)               [ERROR]
	decode_value() (x3: ok, bad_param, excep)               [ERROR]
	encode_value() (x3: ok, bad_param, excep)               [ERROR]
	decode_value() (x3: ok, bad_param, excep)               [ERROR]

WcharType codec 1.2
	encode() (x3: ok, bad_param, except)                    [OK]
	decode() (x3: ok, bad_param, except)                    [OK]
	encode_value() (x3: ok, bad_param, except)              [OK]
	decode_value() (x3: ok, bad_param, except)              [OK]

Test ObjectTypes

ObjectType codec 1.0
	encode()="0" (x3: ok, bad_param, except)                [OK]
	decode()="0" (x3: ok, bad_param, except)                [OK]
	encode_value()="0" (x3: ok, bad_param, except)          [OK]
	decode_value()="0" (x3: ok, bad_param, except)          [OK]

ObjectType codec 1.1
	encode()="0" (x3: ok, bad_param, except)                [OK]
	decode()="0" (x3: ok, bad_param, except)                [OK]
	encode_value()="0" (x3: ok, bad_param, except)          [OK]
	decode_value()="0" (x3: ok, bad_param, except)          [OK]

ObjectType codec 1.2
	encode()="0" (x3: ok, bad_param, except)                [OK]
	decode()="0" (x3: ok, bad_param, except)                [OK]
	encode_value()="0" (x3: ok, bad_param, except)          [OK]
	decode_value()="0" (x3: ok, bad_param, except)          [OK]

ObjectArray codec 1.0
	encode()="0" (x3: ok, bad_param, except)                [OK]
	decode()="0" (x3: ok, bad_param, except)                [OK]
	encode_value()="0" (x3: ok, bad_param, except)          [OK]
	decode_value()="0" (x3: ok, bad_param, except)          [OK]

ObjectArray codec 1.1
	encode()="0" (x3: ok, bad_param, except)                [OK]
	decode()="0" (x3: ok, bad_param, except)                [OK]
	encode_value()="0" (x3: ok, bad_param, except)          [OK]
	decode_value()="0" (x3: ok, bad_param, except)          [OK]

ObjectArray codec 1.2
	encode()="0" (x3: ok, bad_param, except)                [OK]
	decode()="0" (x3: ok, bad_param, except)                [OK]
	encode_value()="0" (x3: ok, bad_param, except)          [OK]
	decode_value()="0" (x3: ok, bad_param, except)          [OK]

typedef_double1 codec 1.0
	encode()="3e+08" (x3: ok, bad_param, except)            [OK]
	decode()="3e+08" (x3: ok, bad_param, except)            [OK]
	encode_value()="3e+08" (x3: ok, bad_param, except)      [OK]
	decode_value()="3e+08" (x3: ok, bad_param, except)      [OK]

typedef_double1 codec 1.1
	encode()="3e+08" (x3: ok, bad_param, except)            [OK]
	decode()="3e+08" (x3: ok, bad_param, except)            [OK]
	encode_value()="3e+08" (x3: ok, bad_param, except)      [OK]
	decode_value()="3e+08" (x3: ok, bad_param, except)      [OK]
typedef_double1 codec 1.2
	encode()="3e+08" (x3: ok, bad_param, except)            [OK]
	decode()="3e+08" (x3: ok, bad_param, except)            [OK]
	encode_value()="3e+08" (x3: ok, bad_param, except)      [OK]
	decode_value()="3e+08" (x3: ok, bad_param, except)      [OK]

typedef_double2 codec 1.0
	encode()="3e+08" (x3: ok, bad_param, except)            [OK]
	decode()="3e+08" (x3: ok, bad_param, except)            [OK]
	encode_value()="3e+08" (x3: ok, bad_param, except)      [OK]
	decode_value()="3e+08" (x3: ok, bad_param, except)      [OK]

typedef_double2 codec 1.1
	encode()="3e+08" (x3: ok, bad_param, except)            [OK]
	decode()="3e+08" (x3: ok, bad_param, except)            [OK]
	encode_value()="3e+08" (x3: ok, bad_param, except)      [OK]
	decode_value()="3e+08" (x3: ok, bad_param, except)      [OK]

typedef_double2 codec 1.2
	encode()="3e+08" (x3: ok, bad_param, except)            [OK]
	decode()="3e+08" (x3: ok, bad_param, except)            [OK]
	encode_value()="3e+08" (x3: ok, bad_param, except)      [OK]
	decode_value()="3e+08" (x3: ok, bad_param, except)      [OK]

typedef_float codec 1.0
	encode()="3.14159" (x3: ok, bad_param, except)          [OK]
	decode()="3.14159" (x3: ok, bad_param, except)          [OK]
	encode_value()="3.14159" (x3: ok, bad_param, except)    [OK]
	decode_value()="3.14159" (x3: ok, bad_param, except)    [OK]
typedef_float codec 1.1
	encode()="3.14159" (x3: ok, bad_param, except)          [OK]
	decode()="3.14159" (x3: ok, bad_param, except)          [OK]
	encode_value()="3.14159" (x3: ok, bad_param, except)    [OK]
	decode_value()="3.14159" (x3: ok, bad_param, except)    [OK]
typedef_float codec 1.2
	encode()="3.14159" (x3: ok, bad_param, except)          [OK]
	decode()="3.14159" (x3: ok, bad_param, except)          [OK]
	encode_value()="3.14159" (x3: ok, bad_param, except)    [OK]
	decode_value()="3.14159" (x3: ok, bad_param, except)    [OK]

typedef_float_array codec 1.0
	encode()="3.14159" (x3: ok, bad_param, except)          [OK]
	decode()="3.14159" (x3: ok, bad_param, except)          [OK]
	encode_value()="3.14159" (x3: ok, bad_param, except)    [OK]
	decode_value()="3.14159" (x3: ok, bad_param, except)    [OK]
typedef_float_array codec 1.1
	encode()="3.14159" (x3: ok, bad_param, except)          [OK]
	decode()="3.14159" (x3: ok, bad_param, except)          [OK]
	encode_value()="3.14159" (x3: ok, bad_param, except)    [OK]
	decode_value()="3.14159" (x3: ok, bad_param, except)    [OK]
typedef_float_array codec 1.2
	encode()="3.14159" (x3: ok, bad_param, except)          [OK]
	decode()="3.14159" (x3: ok, bad_param, except)          [OK]
	encode_value()="3.14159" (x3: ok, bad_param, except)    [OK]
	decode_value()="3.14159" (x3: ok, bad_param, except)    [OK]

typedef_short_array1 codec 1.0
	encode()="128" (x3: ok, bad_param, except)              [OK]
	decode()="128" (x3: ok, bad_param, except)              [OK]
	encode_value()="128" (x3: ok, bad_param, except)        [OK]
	decode_value()="128" (x3: ok, bad_param, except)        [OK]

typedef_short_array1 codec 1.1
	encode()="128" (x3: ok, bad_param, except)              [OK]
	decode()="128" (x3: ok, bad_param, except)              [OK]
	encode_value()="128" (x3: ok, bad_param, except)        [OK]
	decode_value()="128" (x3: ok, bad_param, except)        [OK]

typedef_short_array1 codec 1.2
	encode()="128" (x3: ok, bad_param, except)              [OK]
	decode()="128" (x3: ok, bad_param, except)              [OK]
	encode_value()="128" (x3: ok, bad_param, except)        [OK]
	decode_value()="128" (x3: ok, bad_param, except)        [OK]

typedef_short_array2 codec 1.0
	encode()="128" (x3: ok, bad_param, except)              [OK]
	decode()="128" (x3: ok, bad_param, except)              [OK]
	encode_value()="128" (x3: ok, bad_param, except)        [OK]
	decode_value()="128" (x3: ok, bad_param, except)        [OK]

typedef_short_array2 codec 1.1
	encode()="128" (x3: ok, bad_param, except)              [OK]
	decode()="128" (x3: ok, bad_param, except)              [OK]
	encode_value()="128" (x3: ok, bad_param, except)        [OK]
	decode_value()="128" (x3: ok, bad_param, except)        [OK]

typedef_short_array2 codec 1.2
	encode()="128" (x3: ok, bad_param, except)              [OK]
	decode()="128" (x3: ok, bad_param, except)              [OK]
	encode_value()="128" (x3: ok, bad_param, except)        [OK]
	decode_value()="128" (x3: ok, bad_param, except)        [OK]


Test AnyTypes

AnyType codec 1.0
	encode() (x3: ok, bad_param, except)                    [OK]
	decode() (x3: ok, bad_param, except)                    [OK]
	encode_value() (x3: ok, bad_param, except)              [OK]
	decode_value() (x3: ok, bad_param, except)              [OK]
AnyType codec 1.1
	encode() (x3: ok, bad_param, except)                    [OK]
	decode() (x3: ok, bad_param, except)                    [OK]
	encode_value() (x3: ok, bad_param, except)              [OK]
	decode_value() (x3: ok, bad_param, except)              [OK]
AnyType codec 1.2
	encode() (x3: ok, bad_param, except)                    [OK]
	decode() (x3: ok, bad_param, except)                    [OK]
	encode_value() (x3: ok, bad_param, except)              [OK]
	decode_value() (x3: ok, bad_param, except)              [OK]

AnyFirst codec 1.0
	encode() (x3: ok, bad_param, except)                    [OK]
	decode() (x3: ok, bad_param, except)                    [OK]
	encode_value() (x3: ok, bad_param, except)              [OK]
	decode_value() (x3: ok, bad_param, except)              [OK]

AnyFirst codec 1.1
	encode() (x3: ok, bad_param, except)                    [OK]
	decode() (x3: ok, bad_param, except)                    [OK]
	encode_value() (x3: ok, bad_param, except)              [OK]
	decode_value() (x3: ok, bad_param, except)              [OK]

AnyFirst codec 1.2
	encode() (x3: ok, bad_param, except)                    [OK]
	decode() (x3: ok, bad_param, except)                    [OK]
	encode_value() (x3: ok, bad_param, except)              [OK]
	decode_value() (x3: ok, bad_param, except)              [OK]

AnySecond codec 1.0
	encode() (x3: ok, bad_param, except)                    [OK]
	decode() (x3: ok, bad_param, except)                    [OK]
	encode_value() (x3: ok, bad_param, except)              [OK]
	decode_value() (x3: ok, bad_param, except)              [OK]

AnySecond codec 1.1
	encode() (x3: ok, bad_param, except)                    [OK]
	decode() (x3: ok, bad_param, except)                    [OK]
	encode_value() (x3: ok, bad_param, except)              [OK]
	decode_value() (x3: ok, bad_param, except)              [OK]

AnySecond codec 1.2
	encode() (x3: ok, bad_param, except)                    [OK]
	decode() (x3: ok, bad_param, except)                    [OK]
	encode_value() (x3: ok, bad_param, except)              [OK]
	decode_value() (x3: ok, bad_param, except)              [OK]


Test StructTypes

Struct.FloatType codec 1.0
	encode()="3.14159" (x3: ok, bad_param, except)          [OK]
	decode()="3.14159" (x3: ok, bad_param, except)          [OK]
	encode_value()="3.14159" (x3: ok, bad_param, except)    [OK]
	decode_value()="3.14159" (x3: ok, bad_param, except)    [OK]

Struct.FloatType codec 1.1
	encode()="3.14159" (x3: ok, bad_param, except)          [OK]
	decode()="3.14159" (x3: ok, bad_param, except)          [OK]
	encode_value()="3.14159" (x3: ok, bad_param, except)    [OK]
	decode_value()="3.14159" (x3: ok, bad_param, except)    [OK]

Struct.FloatType codec 1.2
	encode()="3.14159" (x3: ok, bad_param, except)          [OK]
	decode()="3.14159" (x3: ok, bad_param, except)          [OK]
	encode_value()="3.14159" (x3: ok, bad_param, except)    [OK]
	decode_value()="3.14159" (x3: ok, bad_param, except)    [OK]

Struct.DoubleType codec 1.0
	encode()="3e+08" (x3: ok, bad_param, except)            [OK]
	decode()="3e+08" (x3: ok, bad_param, except)            [OK]
	encode_value()="3e+08" (x3: ok, bad_param, except)      [OK]
	decode_value()="3e+08" (x3: ok, bad_param, except)      [OK]

Struct.DoubleType codec 1.1
	encode()="3e+08" (x3: ok, bad_param, except)            [OK]
	decode()="3e+08" (x3: ok, bad_param, except)            [OK]
	encode_value()="3e+08" (x3: ok, bad_param, except)      [OK]
	decode_value()="3e+08" (x3: ok, bad_param, except)      [OK]
Struct.DoubleType codec 1.2
	encode()="3e+08" (x3: ok, bad_param, except)            [OK]
	decode()="3e+08" (x3: ok, bad_param, except)            [OK]
	encode_value()="3e+08" (x3: ok, bad_param, except)      [OK]
	decode_value()="3e+08" (x3: ok, bad_param, except)      [OK]

Struct.LongType codec 1.0
	encode()="314159" (x3: ok, bad_param, except)           [OK]
	decode()="314159" (x3: ok, bad_param, except)           [OK]
	encode_value()="314159" (x3: ok, bad_param, except)     [OK]
	decode_value()="314159" (x3: ok, bad_param, except)     [OK]

Struct.LongType codec 1.1
	encode()="314159" (x3: ok, bad_param, except)           [OK]
	decode()="314159" (x3: ok, bad_param, except)           [OK]
	encode_value()="314159" (x3: ok, bad_param, except)     [OK]
	decode_value()="314159" (x3: ok, bad_param, except)     [OK]

Struct.LongType codec 1.2
	encode()="314159" (x3: ok, bad_param, except)           [OK]
	decode()="314159" (x3: ok, bad_param, except)           [OK]
	encode_value()="314159" (x3: ok, bad_param, except)     [OK]
	decode_value()="314159" (x3: ok, bad_param, except)     [OK]

Struct.UnsignedLongType codec 1.0
	encode()="314159" (x3: ok, bad_param, except)           [OK]
	decode()="314159" (x3: ok, bad_param, except)           [OK]
	encode_value()="314159" (x3: ok, bad_param, except)     [OK]
	decode_value()="314159" (x3: ok, bad_param, except)     [OK]

Struct.UnsignedLongType codec 1.1
	encode()="314159" (x3: ok, bad_param, except)           [OK]
	decode()="314159" (x3: ok, bad_param, except)           [OK]
	encode_value()="314159" (x3: ok, bad_param, except)     [OK]
	decode_value()="314159" (x3: ok, bad_param, except)     [OK]

Struct.UnsignedLongType codec 1.2
	encode()="314159" (x3: ok, bad_param, except)           [OK]
	decode()="314159" (x3: ok, bad_param, except)           [OK]
	encode_value()="314159" (x3: ok, bad_param, except)     [OK]
	decode_value()="314159" (x3: ok, bad_param, except)     [OK]

Struct.ShortType codec 1.0
	encode()="128" (x3: ok, bad_param, except)              [OK]
	decode()="128" (x3: ok, bad_param, except)              [OK]
	encode_value()="128" (x3: ok, bad_param, except)        [OK]
	decode_value()="128" (x3: ok, bad_param, except)        [OK]

Struct.ShortType codec 1.1
	encode()="128" (x3: ok, bad_param, except)              [OK]
	decode()="128" (x3: ok, bad_param, except)              [OK]
	encode_value()="128" (x3: ok, bad_param, except)        [OK]
	decode_value()="128" (x3: ok, bad_param, except)        [OK]

Struct.ShortType codec 1.2
	encode()="128" (x3: ok, bad_param, except)              [OK]
	decode()="128" (x3: ok, bad_param, except)              [OK]
	encode_value()="128" (x3: ok, bad_param, except)        [OK]
	decode_value()="128" (x3: ok, bad_param, except)        [OK]

Struct.UnsignedShortType codec 1.0
	encode()="128" (x3: ok, bad_param, except)              [OK]
	decode()="128" (x3: ok, bad_param, except)              [OK]
	encode_value()="128" (x3: ok, bad_param, except)        [OK]
	decode_value()="128" (x3: ok, bad_param, except)        [OK]

Struct.UnsignedShortType codec 1.1
	encode()="128" (x3: ok, bad_param, except)              [OK]
	decode()="128" (x3: ok, bad_param, except)              [OK]
	encode_value()="128" (x3: ok, bad_param, except)        [OK]
	decode_value()="128" (x3: ok, bad_param, except)        [OK]

Struct.UnsignedShortType codec 1.2
	encode()="128" (x3: ok, bad_param, except)              [OK]
	decode()="128" (x3: ok, bad_param, except)              [OK]
	encode_value()="128" (x3: ok, bad_param, except)        [OK]
	decode_value()="128" (x3: ok, bad_param, except)        [OK]

Struct.CharType codec 1.0
	encode()="Â" (x3: ok, bad_param, except)            [OK]
	decode()="Â" (x3: ok, bad_param, except)            [OK]
	encode_value()="Â" (x3: ok, bad_param, except)      [OK]
	decode_value()="Â" (x3: ok, bad_param, except)      [OK]

Struct.CharType codec 1.1
	encode()="Â" (x3: ok, bad_param, except)            [OK]
	decode()="Â" (x3: ok, bad_param, except)            [OK]
	encode_value()="Â" (x3: ok, bad_param, except)      [OK]
	decode_value()="Â" (x3: ok, bad_param, except)      [OK]

Struct.CharType codec 1.2
	encode()="Â" (x3: ok, bad_param, except)            [OK]
	decode()="Â" (x3: ok, bad_param, except)            [OK]
	encode_value()="Â" (x3: ok, bad_param, except)      [OK]
	decode_value()="Â" (x3: ok, bad_param, except)      [OK]

Struct.WcharType codec 1.0
	encode()="128" (x3: ok, bad_param, except)              [OK]
	decode()="128" (x3: ok, bad_param, except)              [OK]
	encode_value()="128" (x3: ok, bad_param, except)        [OK]
	decode_value()="128" (x3: ok, bad_param, except)        [OK]

Struct.WcharType codec 1.1
	encode()="128" (x3: ok, bad_param, except)              [OK]
	decode()="128" (x3: ok, bad_param, except)              [OK]
	encode_value()="128" (x3: ok, bad_param, except)        [OK]
	decode_value()="128" (x3: ok, bad_param, except)        [OK]

Struct.WcharType codec 1.2
	encode()="128" (x3: ok, bad_param, except)              [OK]
	decode()="128" (x3: ok, bad_param, except)              [OK]
	encode_value()="128" (x3: ok, bad_param, except)        [OK]
	decode_value()="128" (x3: ok, bad_param, except)        [OK]

Struct.BooleanType codec 1.0
	encode()="1" (x3: ok, bad_param, except)                [OK]
	decode()="1" (x3: ok, bad_param, except)                [OK]
	encode_value()="1" (x3: ok, bad_param, except)          [OK]
	decode_value()="1" (x3: ok, bad_param, except)          [OK]

Struct.BooleanType codec 1.1
	encode()="1" (x3: ok, bad_param, except)                [OK]
	decode()="1" (x3: ok, bad_param, except)                [OK]
	encode_value()="1" (x3: ok, bad_param, except)          [OK]
	decode_value()="1" (x3: ok, bad_param, except)          [OK]

Struct.BooleanType codec 1.2
	encode()="1" (x3: ok, bad_param, except)                [OK]
	decode()="1" (x3: ok, bad_param, except)                [OK]
	encode_value()="1" (x3: ok, bad_param, except)          [OK]
	decode_value()="1" (x3: ok, bad_param, except)          [OK]

Struct.OctetType codec 1.0
	encode()="Â" (x3: ok, bad_param, except)            [OK]
	decode()="Â" (x3: ok, bad_param, except)            [OK]
	encode_value()="Â" (x3: ok, bad_param, except)      [OK]
	decode_value()="Â" (x3: ok, bad_param, except)      [OK]

Struct.OctetType codec 1.1
	encode()="Â" (x3: ok, bad_param, except)            [OK]
	decode()="Â" (x3: ok, bad_param, except)            [OK]
	encode_value()="Â" (x3: ok, bad_param, except)      [OK]
	decode_value()="Â" (x3: ok, bad_param, except)      [OK]

Struct.OctetType codec 1.2
	encode()="Â" (x3: ok, bad_param, except)            [OK]
	decode()="Â" (x3: ok, bad_param, except)            [OK]
	encode_value()="Â" (x3: ok, bad_param, except)      [OK]
	decode_value()="Â" (x3: ok, bad_param, except)      [OK]

Struct.LongDoubleType codec 1.0
	encode()="3e+08" (x3: ok, bad_param, except)            [OK]
	decode()="3e+08" (x3: ok, bad_param, except)            [OK]
	encode_value()="3e+08" (x3: ok, bad_param, except)      [OK]
	decode_value()="3e+08" (x3: ok, bad_param, except)      [OK]

Struct.LongDoubleType codec 1.1
	encode()="3e+08" (x3: ok, bad_param, except)            [OK]
	decode()="3e+08" (x3: ok, bad_param, except)            [OK]
	encode_value()="3e+08" (x3: ok, bad_param, except)      [OK]
	decode_value()="3e+08" (x3: ok, bad_param, except)      [OK]

Struct.LongDoubleType codec 1.2
	encode()="3e+08" (x3: ok, bad_param, except)            [OK]
	decode()="3e+08" (x3: ok, bad_param, except)            [OK]
	encode_value()="3e+08" (x3: ok, bad_param, except)      [OK]
	decode_value()="3e+08" (x3: ok, bad_param, except)      [OK]

Struct.LongLongType codec 1.0
	encode()="3141592" (x3: ok, bad_param, except)          [OK]
	decode()="3141592" (x3: ok, bad_param, except)          [OK]
	encode_value()="3141592" (x3: ok, bad_param, except)    [OK]
	decode_value()="3141592" (x3: ok, bad_param, except)    [OK]

Struct.LongLongType codec 1.1
	encode()="3141592" (x3: ok, bad_param, except)          [OK]
	decode()="3141592" (x3: ok, bad_param, except)          [OK]
	encode_value()="3141592" (x3: ok, bad_param, except)    [OK]
	decode_value()="3141592" (x3: ok, bad_param, except)    [OK]

Struct.LongLongType codec 1.2
	encode()="3141592" (x3: ok, bad_param, except)          [OK]
	decode()="3141592" (x3: ok, bad_param, except)          [OK]
	encode_value()="3141592" (x3: ok, bad_param, except)    [OK]
	decode_value()="3141592" (x3: ok, bad_param, except)    [OK]

Struct.UnsignedLongLongType codec 1.0
	encode()="3141592" (x3: ok, bad_param, except)          [OK]
	decode()="3141592" (x3: ok, bad_param, except)          [OK]
	encode_value()="3141592" (x3: ok, bad_param, except)    [OK]
	decode_value()="3141592" (x3: ok, bad_param, except)    [OK]

Struct.UnsignedLongLongType codec 1.1
	encode()="3141592" (x3: ok, bad_param, except)          [OK]
	decode()="3141592" (x3: ok, bad_param, except)          [OK]
	encode_value()="3141592" (x3: ok, bad_param, except)    [OK]
	decode_value()="3141592" (x3: ok, bad_param, except)    [OK]

Struct.UnsignedLongLongType codec 1.2
	encode()="3141592" (x3: ok, bad_param, except)          [OK]
	decode()="3141592" (x3: ok, bad_param, except)          [OK]
	encode_value()="3141592" (x3: ok, bad_param, except)    [OK]
	decode_value()="3141592" (x3: ok, bad_param, except)    [OK]


Test Arrays

ArrayFloatType codec 1.0
	encode()="3.14159" (x3: ok, bad_param, except)          [OK]
	decode()="3.14159" (x3: ok, bad_param, except)          [OK]
	encode_value()="3.14159" (x3: ok, bad_param, except)    [OK]
	decode_value()="3.14159" (x3: ok, bad_param, except)    [OK]

ArrayFloatType codec 1.1
	encode()="3.14159" (x3: ok, bad_param, except)          [OK]
	decode()="3.14159" (x3: ok, bad_param, except)          [OK]
	encode_value()="3.14159" (x3: ok, bad_param, except)    [OK]
	decode_value()="3.14159" (x3: ok, bad_param, except)    [OK]

ArrayFloatType codec 1.2
	encode()="3.14159" (x3: ok, bad_param, except)          [OK]
	decode()="3.14159" (x3: ok, bad_param, except)          [OK]
	encode_value()="3.14159" (x3: ok, bad_param, except)    [OK]
	decode_value()="3.14159" (x3: ok, bad_param, except)    [OK]

ArrayDoubleType codec 1.0
	encode()="3e+08" (x3: ok, bad_param, except)            [OK]
	decode()="3e+08" (x3: ok, bad_param, except)            [OK]
	encode_value()="3e+08" (x3: ok, bad_param, except)      [OK]
	decode_value()="3e+08" (x3: ok, bad_param, except)      [OK]

ArrayDoubleType codec 1.1
	encode()="3e+08" (x3: ok, bad_param, except)            [OK]
	decode()="3e+08" (x3: ok, bad_param, except)            [OK]
	encode_value()="3e+08" (x3: ok, bad_param, except)      [OK]
	decode_value()="3e+08" (x3: ok, bad_param, except)      [OK]

ArrayDoubleType codec 1.2
	encode()="3e+08" (x3: ok, bad_param, except)            [OK]
	decode()="3e+08" (x3: ok, bad_param, except)            [OK]
	encode_value()="3e+08" (x3: ok, bad_param, except)      [OK]
	decode_value()="3e+08" (x3: ok, bad_param, except)      [OK]

ArrayLongType codec 1.0
	encode()="3141592" (x3: ok, bad_param, except)          [OK]
	decode()="3141592" (x3: ok, bad_param, except)          [OK]
	encode_value()="3141592" (x3: ok, bad_param, except)    [OK]
	decode_value()="3141592" (x3: ok, bad_param, except)    [OK]

ArrayLongType codec 1.1
	encode()="3141592" (x3: ok, bad_param, except)          [OK]
	decode()="3141592" (x3: ok, bad_param, except)          [OK]
	encode_value()="3141592" (x3: ok, bad_param, except)    [OK]
	decode_value()="3141592" (x3: ok, bad_param, except)    [OK]

ArrayLongType codec 1.2
	encode()="3141592" (x3: ok, bad_param, except)          [OK]
	decode()="3141592" (x3: ok, bad_param, except)          [OK]
	encode_value()="3141592" (x3: ok, bad_param, except)    [OK]
	decode_value()="3141592" (x3: ok, bad_param, except)    [OK]

ArrayUnsignedLongType codec 1.0
	encode()="3141592" (x3: ok, bad_param, except)          [OK]
	decode()="3141592" (x3: ok, bad_param, except)          [OK]
	encode_value()="3141592" (x3: ok, bad_param, except)    [OK]
	decode_value()="3141592" (x3: ok, bad_param, except)    [OK]

ArrayUnsignedLongType codec 1.1
	encode()="3141592" (x3: ok, bad_param, except)          [OK]
	decode()="3141592" (x3: ok, bad_param, except)          [OK]
	encode_value()="3141592" (x3: ok, bad_param, except)    [OK]
	decode_value()="3141592" (x3: ok, bad_param, except)    [OK]

ArrayUnsignedLongType codec 1.2
	encode()="3141592" (x3: ok, bad_param, except)          [OK]
	decode()="3141592" (x3: ok, bad_param, except)          [OK]
	encode_value()="3141592" (x3: ok, bad_param, except)    [OK]
	decode_value()="3141592" (x3: ok, bad_param, except)    [OK]

ArrayShortType codec 1.0
	encode()="128" (x3: ok, bad_param, except)              [OK]
	decode()="128" (x3: ok, bad_param, except)              [OK]
	encode_value()="128" (x3: ok, bad_param, except)        [OK]
	decode_value()="128" (x3: ok, bad_param, except)        [OK]

ArrayShortType codec 1.1
	encode()="128" (x3: ok, bad_param, except)              [OK]
	decode()="128" (x3: ok, bad_param, except)              [OK]
	encode_value()="128" (x3: ok, bad_param, except)        [OK]
	decode_value()="128" (x3: ok, bad_param, except)        [OK]

ArrayShortType codec 1.2
	encode()="128" (x3: ok, bad_param, except)              [OK]
	decode()="128" (x3: ok, bad_param, except)              [OK]
	encode_value()="128" (x3: ok, bad_param, except)        [OK]
	decode_value()="128" (x3: ok, bad_param, except)        [OK]

ArrayUnsignedShortType codec 1.0
	encode()="128" (x3: ok, bad_param, except)              [OK]
	decode()="128" (x3: ok, bad_param, except)              [OK]
	encode_value()="128" (x3: ok, bad_param, except)        [OK]
	decode_value()="128" (x3: ok, bad_param, except)        [OK]

ArrayUnsignedShortType codec 1.1
	encode()="128" (x3: ok, bad_param, except)              [OK]
	decode()="128" (x3: ok, bad_param, except)              [OK]
	encode_value()="128" (x3: ok, bad_param, except)        [OK]
	decode_value()="128" (x3: ok, bad_param, except)        [OK]

ArrayUnsignedShortType codec 1.2
	encode()="128" (x3: ok, bad_param, except)              [OK]
	decode()="128" (x3: ok, bad_param, except)              [OK]
	encode_value()="128" (x3: ok, bad_param, except)        [OK]
	decode_value()="128" (x3: ok, bad_param, except)        [OK]

ArrayBooleanType codec 1.0
	encode()="1" (x3: ok, bad_param, except)                [OK]
	decode()="1" (x3: ok, bad_param, except)                [OK]
	encode_value()="1" (x3: ok, bad_param, except)          [OK]
	decode_value()="1" (x3: ok, bad_param, except)          [OK]

ArrayBooleanType codec 1.1
	encode()="1" (x3: ok, bad_param, except)                [OK]
	decode()="1" (x3: ok, bad_param, except)                [OK]
	encode_value()="1" (x3: ok, bad_param, except)          [OK]
	decode_value()="1" (x3: ok, bad_param, except)          [OK]

ArrayBooleanType codec 1.2
	encode()="1" (x3: ok, bad_param, except)                [OK]
	decode()="1" (x3: ok, bad_param, except)                [OK]
	encode_value()="1" (x3: ok, bad_param, except)          [OK]
	decode_value()="1" (x3: ok, bad_param, except)          [OK]

ArrayOctetType codec 1.0
	encode()="Â" (x3: ok, bad_param, except)            [OK]
	decode()="Â" (x3: ok, bad_param, except)            [OK]
	encode_value()="Â" (x3: ok, bad_param, except)      [OK]
	decode_value()="Â" (x3: ok, bad_param, except)      [OK]

ArrayOctetType codec 1.1
	encode()="Â" (x3: ok, bad_param, except)            [OK]
	decode()="Â" (x3: ok, bad_param, except)            [OK]
	encode_value()="Â" (x3: ok, bad_param, except)      [OK]
	decode_value()="Â" (x3: ok, bad_param, except)      [OK]

ArrayOctetType codec 1.2
	encode()="Â" (x3: ok, bad_param, except)            [OK]
	decode()="Â" (x3: ok, bad_param, except)            [OK]
	encode_value()="Â" (x3: ok, bad_param, except)      [OK]
	decode_value()="Â" (x3: ok, bad_param, except)      [OK]

ArrayLongDoubleType codec 1.0
	encode()="3e+08" (x3: ok, bad_param, except)            [OK]
	decode()="3e+08" (x3: ok, bad_param, except)            [OK]
	encode_value()="3e+08" (x3: ok, bad_param, except)      [OK]
	decode_value()="3e+08" (x3: ok, bad_param, except)      [OK]

ArrayLongDoubleType codec 1.1
	encode()="3e+08" (x3: ok, bad_param, except)            [OK]
	decode()="3e+08" (x3: ok, bad_param, except)            [OK]
	encode_value()="3e+08" (x3: ok, bad_param, except)      [OK]
	decode_value()="3e+08" (x3: ok, bad_param, except)      [OK]

ArrayLongDoubleType codec 1.2
	encode()="3e+08" (x3: ok, bad_param, except)            [OK]
	decode()="3e+08" (x3: ok, bad_param, except)            [OK]
	encode_value()="3e+08" (x3: ok, bad_param, except)      [OK]
	decode_value()="3e+08" (x3: ok, bad_param, except)      [OK]

ArrayLongLongType codec 1.0
	encode()="3141592" (x3: ok, bad_param, except)          [OK]
	decode()="3141592" (x3: ok, bad_param, except)          [OK]
	encode_value()="3141592" (x3: ok, bad_param, except)    [OK]
	decode_value()="3141592" (x3: ok, bad_param, except)    [OK]

ArrayLongLongType codec 1.1
	encode()="3141592" (x3: ok, bad_param, except)          [OK]
	decode()="3141592" (x3: ok, bad_param, except)          [OK]
	encode_value()="3141592" (x3: ok, bad_param, except)    [OK]
	decode_value()="3141592" (x3: ok, bad_param, except)    [OK]

ArrayLongLongType codec 1.2
	encode()="3141592" (x3: ok, bad_param, except)          [OK]
	decode()="3141592" (x3: ok, bad_param, except)          [OK]
	encode_value()="3141592" (x3: ok, bad_param, except)    [OK]
	decode_value()="3141592" (x3: ok, bad_param, except)    [OK]

ArrayUnsignedLongLongType codec 1.0
	encode()="3141592" (x3: ok, bad_param, except)          [OK]
	decode()="3141592" (x3: ok, bad_param, except)          [OK]
	encode_value()="3141592" (x3: ok, bad_param, except)    [OK]
	decode_value()="3141592" (x3: ok, bad_param, except)    [OK]

ArrayUnsignedLongLongType codec 1.1
	encode()="3141592" (x3: ok, bad_param, except)          [OK]
	decode()="3141592" (x3: ok, bad_param, except)          [OK]
	encode_value()="3141592" (x3: ok, bad_param, except)    [OK]
	decode_value()="3141592" (x3: ok, bad_param, except)    [OK]

ArrayUnsignedLongLongType codec 1.2
	encode()="3141592" (x3: ok, bad_param, except)          [OK]
	decode()="3141592" (x3: ok, bad_param, except)          [OK]
	encode_value()="3141592" (x3: ok, bad_param, except)    [OK]
	decode_value()="3141592" (x3: ok, bad_param, except)    [OK]

FloatArrayBi codec 1.0
	encode()="314159" (x3: ok, bad_param, except)           [OK]
	decode()="314159" (x3: ok, bad_param, except)           [OK]
	encode_value()="314159" (x3: ok, bad_param, except)     [OK]
	decode_value()="314159" (x3: ok, bad_param, except)     [OK]

FloatArrayBi codec 1.1
	encode()="314159" (x3: ok, bad_param, except)           [OK]
	decode()="314159" (x3: ok, bad_param, except)           [OK]
	encode_value()="314159" (x3: ok, bad_param, except)     [OK]
	decode_value()="314159" (x3: ok, bad_param, except)     [OK]

FloatArrayBi codec 1.2
	encode()="314159" (x3: ok, bad_param, except)           [OK]
	decode()="314159" (x3: ok, bad_param, except)           [OK]
	encode_value()="314159" (x3: ok, bad_param, except)     [OK]
	decode_value()="314159" (x3: ok, bad_param, except)     [OK]

Struct.arrayFloatType codec 1.0
	encode()="3.14159" (x3: ok, bad_param, except)          [OK]
	decode()="3.14159" (x3: ok, bad_param, except)          [OK]
	encode_value()="3.14159" (x3: ok, bad_param, except)    [OK]
	decode_value()="3.14159" (x3: ok, bad_param, except)    [OK]

Struct.arrayFloatType codec 1.1
	encode()="3.14159" (x3: ok, bad_param, except)          [OK]
	decode()="3.14159" (x3: ok, bad_param, except)          [OK]
	encode_value()="3.14159" (x3: ok, bad_param, except)    [OK]
	decode_value()="3.14159" (x3: ok, bad_param, except)    [OK]

Struct.arrayFloatType codec 1.2
	encode()="3.14159" (x3: ok, bad_param, except)          [OK]
	decode()="3.14159" (x3: ok, bad_param, except)          [OK]
	encode_value()="3.14159" (x3: ok, bad_param, except)    [OK]
	decode_value()="3.14159" (x3: ok, bad_param, except)    [OK]

Struct.arrayDoubleType codec 1.0
	encode()="3e+08" (x3: ok, bad_param, except)            [OK]
	decode()="3e+08" (x3: ok, bad_param, except)            [OK]
	encode_value()="3e+08" (x3: ok, bad_param, except)      [OK]
	decode_value()="3e+08" (x3: ok, bad_param, except)      [OK]

Struct.arrayDoubleType codec 1.1
	encode()="3e+08" (x3: ok, bad_param, except)            [OK]
	decode()="3e+08" (x3: ok, bad_param, except)            [OK]
	encode_value()="3e+08" (x3: ok, bad_param, except)      [OK]
	decode_value()="3e+08" (x3: ok, bad_param, except)      [OK]

Struct.arrayDoubleType codec 1.2
	encode()="3e+08" (x3: ok, bad_param, except)            [OK]
	decode()="3e+08" (x3: ok, bad_param, except)            [OK]
	encode_value()="3e+08" (x3: ok, bad_param, except)      [OK]
	decode_value()="3e+08" (x3: ok, bad_param, except)      [OK]

Struct.arrayLongType codec 1.0
	encode()="314159" (x3: ok, bad_param, except)           [OK]
	decode()="314159" (x3: ok, bad_param, except)           [OK]
	encode_value()="314159" (x3: ok, bad_param, except)     [OK]
	decode_value()="314159" (x3: ok, bad_param, except)     [OK]

Struct.arrayLongType codec 1.1
	encode()="314159" (x3: ok, bad_param, except)           [OK]
	decode()="314159" (x3: ok, bad_param, except)           [OK]
	encode_value()="314159" (x3: ok, bad_param, except)     [OK]
	decode_value()="314159" (x3: ok, bad_param, except)     [OK]

Struct.arrayLongType codec 1.2
	encode()="314159" (x3: ok, bad_param, except)           [OK]
	decode()="314159" (x3: ok, bad_param, except)           [OK]
	encode_value()="314159" (x3: ok, bad_param, except)     [OK]
	decode_value()="314159" (x3: ok, bad_param, except)     [OK]

Struct.arrayULongType codec 1.0
	encode()="314159" (x3: ok, bad_param, except)           [OK]
	decode()="314159" (x3: ok, bad_param, except)           [OK]
	encode_value()="314159" (x3: ok, bad_param, except)     [OK]
	decode_value()="314159" (x3: ok, bad_param, except)     [OK]

Struct.arrayULongType codec 1.1
	encode()="314159" (x3: ok, bad_param, except)           [OK]
	decode()="314159" (x3: ok, bad_param, except)           [OK]
	encode_value()="314159" (x3: ok, bad_param, except)     [OK]
	decode_value()="314159" (x3: ok, bad_param, except)     [OK]

Struct.arrayULongType codec 1.2
	encode()="314159" (x3: ok, bad_param, except)           [OK]
	decode()="314159" (x3: ok, bad_param, except)           [OK]
	encode_value()="314159" (x3: ok, bad_param, except)     [OK]
	decode_value()="314159" (x3: ok, bad_param, except)     [OK]

Struct.arrayShortType codec 1.0
	encode()="128" (x3: ok, bad_param, except)              [OK]
	decode()="128" (x3: ok, bad_param, except)              [OK] 
	encode_value()="128" (x3: ok, bad_param, except)        [OK]
	decode_value()="128" (x3: ok, bad_param, except)        [OK]

Struct.arrayShortType codec 1.1
	encode()="128" (x3: ok, bad_param, except)              [OK]
	decode()="128" (x3: ok, bad_param, except)              [OK]
	encode_value()="128" (x3: ok, bad_param, except)        [OK]
	decode_value()="128" (x3: ok, bad_param, except)        [OK]

Struct.arrayShortType codec 1.2
	encode()="128" (x3: ok, bad_param, except)              [OK]
	decode()="128" (x3: ok, bad_param, except)              [OK]
	encode_value()="128" (x3: ok, bad_param, except)        [OK]
	decode_value()="128" (x3: ok, bad_param, except)        [OK]

Struct.arrayUShortType codec 1.0
	encode()="128" (x3: ok, bad_param, except)              [OK]
	decode()="128" (x3: ok, bad_param, except)              [OK]
	encode_value()="128" (x3: ok, bad_param, except)        [OK]
	decode_value()="128" (x3: ok, bad_param, except)        [OK]

Struct.arrayUShortType codec 1.1
	encode()="128" (x3: ok, bad_param, except)              [OK]
	decode()="128" (x3: ok, bad_param, except)              [OK]
	encode_value()="128" (x3: ok, bad_param, except)        [OK]
	decode_value()="128" (x3: ok, bad_param, except)        [OK]

Struct.arrayUShortType codec 1.2
	encode()="128" (x3: ok, bad_param, except)              [OK]
	decode()="128" (x3: ok, bad_param, except)              [OK]
	encode_value()="128" (x3: ok, bad_param, except)        [OK]
	decode_value()="128" (x3: ok, bad_param, except)        [OK]

Struct.arrayBooleanType codec 1.0
	encode()="1" (x3: ok, bad_param, except)                [OK]
	decode()="1" (x3: ok, bad_param, except)                [OK]
	encode_value()="1" (x3: ok, bad_param, except)          [OK]
	decode_value()="1" (x3: ok, bad_param, except)          [OK]

Struct.arrayBooleanType codec 1.1
	encode()="1" (x3: ok, bad_param, except)                [OK]
	decode()="1" (x3: ok, bad_param, except)                [OK]
	encode_value()="1" (x3: ok, bad_param, except)          [OK]
	decode_value()="1" (x3: ok, bad_param, except)          [OK]

Struct.arrayBooleanType codec 1.2
	encode()="1" (x3: ok, bad_param, except)                [OK]
	decode()="1" (x3: ok, bad_param, except)                [OK]
	encode_value()="1" (x3: ok, bad_param, except)          [OK]
	decode_value()="1" (x3: ok, bad_param, except)          [OK]

Struct.arrayOctetType codec 1.0
	encode()="Â" (x3: ok, bad_param, except)            [OK]
	decode()="Â" (x3: ok, bad_param, except)            [OK]
	encode_value()="Â" (x3: ok, bad_param, except)      [OK]
	decode_value()="Â" (x3: ok, bad_param, except)      [OK]

Struct.arrayOctetType codec 1.1
	encode()="Â" (x3: ok, bad_param, except)            [OK]
	decode()="Â" (x3: ok, bad_param, except)            [OK]
	encode_value()="Â" (x3: ok, bad_param, except)      [OK]
	decode_value()="Â" (x3: ok, bad_param, except)      [OK]

Struct.arrayOctetType codec 1.2
	encode()="Â" (x3: ok, bad_param, except)            [OK]
	decode()="Â" (x3: ok, bad_param, except)            [OK]
	encode_value()="Â" (x3: ok, bad_param, except)      [OK]
	decode_value()="Â" (x3: ok, bad_param, except)      [OK]

Struct.arrayLongDoubleType codec 1.0
	encode()="3e+08" (x3: ok, bad_param, except)            [OK]
	decode()="3e+08" (x3: ok, bad_param, except)            [OK]
	encode_value()="3e+08" (x3: ok, bad_param, except)      [OK]
	decode_value()="3e+08" (x3: ok, bad_param, except)      [OK]

Struct.arrayLongDoubleType codec 1.1
	encode()="3e+08" (x3: ok, bad_param, except)            [OK]
	decode()="3e+08" (x3: ok, bad_param, except)            [OK]
	encode_value()="3e+08" (x3: ok, bad_param, except)      [OK]
	decode_value()="3e+08" (x3: ok, bad_param, except)      [OK]

Struct.arrayLongDoubleType codec 1.2
	encode()="3e+08" (x3: ok, bad_param, except)            [OK]
	decode()="3e+08" (x3: ok, bad_param, except)            [OK]
	encode_value()="3e+08" (x3: ok, bad_param, except)      [OK]
	decode_value()="3e+08" (x3: ok, bad_param, except)      [OK]

Struct.arrayLongLongType codec 1.0
	encode()="314159" (x3: ok, bad_param, except)           [OK]
	decode()="314159" (x3: ok, bad_param, except)           [OK]
	encode_value()="314159" (x3: ok, bad_param, except)     [OK]
	decode_value()="314159" (x3: ok, bad_param, except)     [OK]

Struct.arrayLongLongType codec 1.1
	encode()="314159" (x3: ok, bad_param, except)           [OK]
	decode()="314159" (x3: ok, bad_param, except)           [OK]
	encode_value()="314159" (x3: ok, bad_param, except)     [OK]
	decode_value()="314159" (x3: ok, bad_param, except)     [OK]

Struct.arrayLongLongType codec 1.2
	encode()="314159" (x3: ok, bad_param, except)           [OK]
	decode()="314159" (x3: ok, bad_param, except)           [OK]
	encode_value()="314159" (x3: ok, bad_param, except)     [OK]
	decode_value()="314159" (x3: ok, bad_param, except)     [OK]

Struct.arrayULongLongType codec 1.0
	encode()="314159" (x3: ok, bad_param, except)           [OK]
	decode()="314159" (x3: ok, bad_param, except)           [OK]
	encode_value()="314159" (x3: ok, bad_param, except)     [OK]
	decode_value()="314159" (x3: ok, bad_param, except)     [OK]

Struct.arrayULongLongType codec 1.1
	encode()="314159" (x3: ok, bad_param, except)           [OK]
	decode()="314159" (x3: ok, bad_param, except)           [OK]
	encode_value()="314159" (x3: ok, bad_param, except)     [OK]
	decode_value()="314159" (x3: ok, bad_param, except)     [OK]

Struct.arrayULongLongType codec 1.2
	encode()="314159" (x3: ok, bad_param, except)           [OK]
	decode()="314159" (x3: ok, bad_param, except)           [OK]
	encode_value()="314159" (x3: ok, bad_param, except)     [OK]
	decode_value()="314159" (x3: ok, bad_param, except)     [OK]


* MIOP (CORBA 2.6 - Chapter 29)
-------------------------------

·Structurals Tests
==================

Test Case MIOP
--------------
Test GOA_Interface
	 
PortableGroup::GOA_ptr _narrow(obj)                             [OK]
PortableGroup::GOA_ptr _unchecked_narrow(obj)                   [OK]
PortableServer::ObjectId create_id_for_reference(the_ref)       [OK]
IDs reference_to_ids (in Object the_ref)                        [OK]
void associate_reference_with_id (ref, oid)                     [OK]
void disassociate_reference_with_id (ref, oid)                  [OK]


·Functional Tests
=================

Checking GOA (29.18.3)

Setup Section:  ORB_init + RootPOA                              [OK]
PortableGroup::GOA::_narrow(root_poa)                           [OK]
root_poa->the_POAManager                                        [OK]
poa_manager->activate                                           [OK]


Checking MIOP URL (29.14) 
Multicast: corbaloc:miop:1.0@1.0-Consumer-1/225.0.0.1:15984
           
orb->string_to_object (group_ior)                               [OK]
root_poa->create_id_for_reference(group_ior)                    [OK]
root_poa->activate_object_with_id( id, &servant )               [OK]


Checking MIOP Packet Collection (29.3)

Test::Consumer::_unchecked_narrow( obj )                        [OK]
Sending packets of 64 bytes 2 Times                             [OK]                
ConsumerImpl::getDataPackage (size=64)                          [OK]
ConsumerImpl::getDataPackage (size=64)                          [OK]
Sending packets of 512 bytes 2 Times                            [OK]
ConsumerImpl::getDataPackage (size=512)                         [OK]
ConsumerImpl::getDataPackage (size=512)                         [OK]
Sending packets of 4000 bytes 2 Times                           [OK]
ConsumerImpl::getDataPackage (size=4000)                        [OK]
ConsumerImpl::getDataPackage (size=4000)                        [OK]
Sending packets of 32000 bytes 2 Times                          [OK]
ConsumerImpl::getDataPackage (size=32000)                       [OK]
ConsumerImpl::getDataPackage (size=32000)                       [OK]
Sending packets of 65000 bytes 2 Times                          [OK]
ConsumerImpl::getDataPackage (size=65000)                       [OK]
ConsumerImpl::getDataPackage (size=65000)                       [OK]
Sending packets of 128000 bytes 2 Times                         [OK]
ConsumerImpl::getDataPackage (size=128000)                      [OK]
ConsumerImpl::getDataPackage (size=128000)                      [OK]
Sending packets of 256000 bytes 2 Times                         [OK]
onsumerImpl::getDataPackage (size=256000)                       [OK]
ConsumerImpl::getDataPackage (size=256000)                      [OK]


Checking MIOP URL (29.14) 
IP: corbaloc:miop:1.0@1.0-Consumer-1/127.0.0.1:15984

orb->string_to_object (group_ior)                               [OK]
root_poa->create_id_for_reference(group_ior)                    [OK]
root_poa->activate_object_with_id( id, &servant )               [OK]


Checking MIOP Packet Collection (29.3)

Test::Consumer::_unchecked_narrow( obj )                        [OK]
Sending packets of 64 bytes 2 Times                             [OK]
ConsumerImpl::getDataPackage (size=64)                          [OK]
ConsumerImpl::getDataPackage (size=64)                          [OK]
Sending packets of 512 bytes 2 Times                            [OK]
ConsumerImpl::getDataPackage (size=512)                         [OK]
ConsumerImpl::getDataPackage (size=512)                         [OK]
ending packets of 4000 bytes 2 Times                            [OK]
ConsumerImpl::getDataPackage (size=4000)                        [OK]
ConsumerImpl::getDataPackage (size=4000)                        [OK]
Sending packets of 32000 bytes 2 Times                          [OK]
ConsumerImpl::getDataPackage (size=32000)                       [OK]
ConsumerImpl::getDataPackage (size=32000)                       [OK]
Sending packets of 65000 bytes 2 Times                          [OK]
ConsumerImpl::getDataPackage (size=65000)                       [OK]
ConsumerImpl::getDataPackage (size=65000)                       [OK]
Sending packets of 128000 bytes 2 Times                         [OK]
ConsumerImpl::getDataPackage (size=128000)                      [OK]
ConsumerImpl::getDataPackage (size=128000)                      [OK]
Sending packets of 256000 bytes 2 Times                         [OK]
ConsumerImpl::getDataPackage (size=256000)                      [OK]
ConsumerImpl::getDataPackage (size=256000)                      [OK]


Checking MIOP URL (29.14) 
Host: corbaloc:miop:1.0@1.0-Consumer-1/localhost:15984

orb->string_to_object (group_ior)                               [OK]
root_poa->create_id_for_reference(group_ior)                    [OK]
root_poa->activate_object_with_id( id, &servant )               [OK]


Checking MIOP Packet Collection (29.3)

Test::Consumer::_unchecked_narrow( obj )                        [OK]
Sending packets of 64 bytes 2 Times                             [OK]
ConsumerImpl::getDataPackage (size=64)                          [OK]
ConsumerImpl::getDataPackage (size=64)                          [OK]
Sending packets of 512 bytes 2 Times                            [OK]
ConsumerImpl::getDataPackage (size=512)                         [OK]
ConsumerImpl::getDataPackage (size=512)                         [OK]
Sending packets of 4000 bytes 2 Times                           [OK]
ConsumerImpl::getDataPackage (size=4000)                        [OK]
ConsumerImpl::getDataPackage (size=4000)                        [OK]
Sending packets of 32000 bytes 2 Times                          [OK]
ConsumerImpl::getDataPackage (size=32000)                       [OK]
ConsumerImpl::getDataPackage (size=32000)                       [OK]
Sending packets of 65000 bytes 2 Times                          [OK]
ConsumerImpl::getDataPackage (size=65000)                       [OK]
ConsumerImpl::getDataPackage (size=65000)                       [OK]
Sending packets of 128000 bytes 2 Times                         [OK]
ConsumerImpl::getDataPackage (size=128000)                      [OK]
ConsumerImpl::getDataPackage (size=128000)                      [OK]
Sending packets of 256000 bytes 2 Times                         [OK]
ConsumerImpl::getDataPackage (size=256000)                      [OK]
ConsumerImpl::getDataPackage (size=256000)                      [OK]


Checking MIOP URL (29.14) 
Broadcast: corbaloc:miop:1.0@1.0-Consumer-1/127.0.0.255:15984

orb->string_to_object (group_ior)                               [OK]
root_poa->create_id_for_reference(group_ior)                    [OK]       
root_poa->activate_object_with_id( id, &servant )               [OK]


Checking MIOP Packet Collection (29.3)

Test::Consumer::_unchecked_narrow( obj )                        [OK]
Sending packets of 64 bytes 2 Times                             [OK]
ConsumerImpl::getDataPackage (size=64)                          [OK]
ConsumerImpl::getDataPackage (size=64)                          [OK]
Sending packets of 512 bytes 2 Times                            [OK]
ConsumerImpl::getDataPackage (size=512)                         [OK]
ConsumerImpl::getDataPackage (size=512)                         [OK]
Sending packets of 4000 bytes 2 Times                           [OK]
ConsumerImpl::getDataPackage (size=4000)                        [OK]
ConsumerImpl::getDataPackage (size=4000)                        [OK]
Sending packets of 32000 bytes 2 Times                          [OK]
ConsumerImpl::getDataPackage (size=32000)                       [OK]
ConsumerImpl::getDataPackage (size=32000)                       [OK]
Sending packets of 65000 bytes 2 Times                          [OK]
ConsumerImpl::getDataPackage (size=65000)                       [OK]
ConsumerImpl::getDataPackage (size=65000)                       [OK]
Sending packets of 128000 bytes 2 Times                         [OK]
ConsumerImpl::getDataPackage (size=128000)                      [OK]
ConsumerImpl::getDataPackage (size=128000)                      [OK]
Sending packets of 256000 bytes 2 Times                         [OK]
ConsumerImpl::getDataPackage (size=256000)                      [OK]
ConsumerImpl::getDataPackage (size=256000)                      [OK]





* Messaging QoS (CORBA 2.6 - Chapter 22)
----------------------------------------

·Structural Tests
=================

Test Case CORBA_Messaging
-------------------------
Test Messaging_QoS

RebindPolicy                                                    [OK] 
	Messaging::RebindMode rebind_mode()                     [OK]

SyncScopePolicy                                                 [OK]
	Messaging::SyncScope synchronization()                  [OK] 

RequestPriorityPolicy                                           [OK]
	Messaging::PriorityRange priority_range()               [OK] 

ReplyPriorityPolicy                                             [OK]
	Messaging::PriorityRange priority_range()               [OK] 
	::CORBA::PolicyType policy_type()                       [OK] 
	::CORBA::Policy_ptr copy()                              [OK] 
	void destroy()                                          [OK] 

RequestStartTimePolicy                                          [OK]
	TimeBase::UtcT start_time()                             [OK] 

RequestEndTimePolicy                                            [OK]
	TimeBase::UtcT end_time()                               [OK] 

ReplyStartTimePolicy                                            [OK]
	TimeBase::UtcT start_time()                             [OK] 

ReplyEndTimePolicy                                              [OK]
	TimeBase::UtcT end_time()                               [OK] 

RelativeRequestTimeoutPolicy                                    [OK]
	TimeBase::TimeT relative_expiry()                       [OK] 

RelativeRoundtripTimeoutPolicy                                  [OK]
	TimeBase::TimeT relative_expiry()                       [OK] 

RoutingPolicy                                                   [OK]
	Messaging::RoutingTypeRange routing_range()             [OK] 

MaxHopsPolicy                                                   [OK]
	CORBA::UShort max_hops()                                [OK] 

QueueOrderPolicy                                                [OK]
	Messaging::Ordering allowed_orders()                    [OK] 
	 

·Functional Tests
=================

Test Case Messaging_QoS
-----------------------

Test RequestPriorityPolicy

create_policy                                                   [OK]
POA activation                                                  [OK]
policy_manager->set_policy_overrides                            [OK]
test_ref->echo(message) (x 2): ok + exception                   [OK]


Test RequestStartTimePolicy

create_policy                                                   [OK]
POA activation                                                  [OK]
policy_manager->set_policy_overrides                            [OK]
test_ref->echo(message) (x 2): ok + exception                   [OK]


Test RequestEndTimePolicy

create_policy                                                   [OK]
POA activation                                                  [OK]
policy_manager->set_policy_overrides                            [OK]
test_ref->echo(message) (x 2): ok + exception                   [OK]


Test RebindPolicy

create_policy                                                   [OK]
POA activation                                                  [OK]
policy_manager->set_policy_overrides                            [OK]
test_ref->echo(message) (x 2): ok + exception                   [OK]


Test RelativeReqTimeoutPolicy

create_policy (x2)                                              [OK]
POA activation  (x2)                                            [OK]
policy_manager->set_policy_overrides (x2)                       [OK]
test_ref->echo(message) (x 4): ok + exception                   [OK]


Test RelativeRtTimeoutPolicy

create_policy (x2)                                              [OK]
POA activation (x2)                                             [OK]
policy_manager->set_policy_overrides (x2)                       [OK]
test_ref->echo(message) (x 4): ok + exception                   [OK]


Test QueueOrderPolicy

create_policy (x2)                                              [OK]
POA activation (x2)                                             [OK]
policy_manager->set_policy_overrides (x2)                       [OK]
test_ref->echo(message) (x 4): ok + exception                   [OK]




* ZIOP (ZIOP FTF Beta 2)
------------------------

·Structural Tests
=================

CompressionException                                            [OK]
FactoryAlreadyRegistered                                        [OK]
UnknownCompressorId                                             [OK]
CompressorId                                                    [OK]
CompressionLevel                                                [OK]
CompressionRatio                                                [OK]
CompressorIdLevel                                               [OK]
CompressorIdLevelList                                           [OK]

Compressor
        void compress(in Buffer source, inout Buffer target)    [OK]
        void decompress(in Buffer source, inout Buffer target)  [OK]
        CompressorFactory compressor_factory                    [OK]
        CompressionLevel compression_level                      [OK]
        unsigned long long compressed_bytes                     [OK]
        unsigned long long uncompressed_bytes                   [OK]
        CompressionRatio compression_ratio                      [OK]

CompressorFactory
        CompressorId compressor_id                              [OK]
        get_compressor(in CompressionLevel compression_level)   [OK]

CompressionManager
        register_factory()                                      [OK]
        unregister_factory()                                    [OK]
        CompressorFactory get_factory( )                        [OK]
        get_compressor( )                                       [OK]
        get_factories()                                         [OK]


CompressionEnablingPolicy                                       [OK] 
	CompressionEnablingPolicyValue compression_enabled      [OK]

CompressorIdLevelListPolicy                                     [OK]
	Compression::CompressorIdLevelList compressor_ids       [OK] 

CompressionLowValuePolicy                                       [OK]
	CompressionLowValuePolicyValue low_value                [OK] 

CompressionMinRatioPolicy                                       [OK]
	CompressionMinRatioPolicyValue ratio                    [OK] 



·Functional Tests
=================

Test CompressionEnablingPolicy

create_policy                                                   [OK]
POA activation                                                  [OK]
ref->_set_policy_overrides                                      [OK]


Test CompressorIdLevelListPolicy

create_policy                                                   [OK]
POA activation                                                  [OK]
ref->_set_policy_overrides                                      [OK]


Test CompressionLowValuePolicy

create_policy                                                   [OK]
POA activation                                                  [OK]
ref->_set_policy_overrides                                      [OK]


Test CompressionMinRatioPolicy

create_policy                                                   [OK]
POA activation                                                  [OK]
ref->_set_policy_overrides                                      [OK]


Test ZIOP ZlibCompressor

compress                                                        [OK]
decompress                                                      [OK]
test_ref->echo(message) (x 4 sizes)                             [OK]


Test ZIOP CustomCompressor

compress                                                        [OK]
decompress                                                      [OK]
test_ref->echo(message) (x 4 sizes)                             [OK]




